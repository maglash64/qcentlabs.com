<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Making my own Programmer/Debugger using ARM SWD. | qcentlabs</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-PWDYJX7Y6B"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PWDYJX7Y6B")</script><meta name=keywords content><meta name=description content="So, recently at my day job our team needed to develop a PCB test JIG for mass manufacturing/testing of the assembled PCBs.
To increase the efficiency of this test process, the idea of testing and programming multiple boards at once came into my mind.
Initially I thought of using multiple Debuggers/Programmers to flash code into multiple boards at once, but as you know, most of these debuggers aren&rsquo;t cheap.
Except for ST-link V2 clones which are available at dirt cheap prices, all other debuggers cost at least 10s of dollars and from then on special mass production versions of J-link can go on for 1000s of dollars not including professional software that you need to purchase separately for flash programming in a manufacturing setting."><meta name=author content="magalsh64"><link rel=canonical href=http://qcentlabs.com/posts/swd_banger/><meta name=google-site-verification content="G-PWDYJX7Y6B"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://qcentlabs.com/logo.png><link rel=icon type=image/png sizes=16x16 href=http://qcentlabs.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://qcentlabs.com/favicon-32x32.png><link rel=apple-touch-icon href=http://qcentlabs.com/logo.png><link rel=mask-icon href=http://qcentlabs.com/logo.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.119.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Making my own Programmer/Debugger using ARM SWD."><meta property="og:description" content="So, recently at my day job our team needed to develop a PCB test JIG for mass manufacturing/testing of the assembled PCBs.
To increase the efficiency of this test process, the idea of testing and programming multiple boards at once came into my mind.
Initially I thought of using multiple Debuggers/Programmers to flash code into multiple boards at once, but as you know, most of these debuggers aren&rsquo;t cheap.
Except for ST-link V2 clones which are available at dirt cheap prices, all other debuggers cost at least 10s of dollars and from then on special mass production versions of J-link can go on for 1000s of dollars not including professional software that you need to purchase separately for flash programming in a manufacturing setting."><meta property="og:type" content="article"><meta property="og:url" content="http://qcentlabs.com/posts/swd_banger/"><meta property="og:image" content="http://qcentlabs.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-27T01:15:13+05:30"><meta property="article:modified_time" content="2023-06-27T01:15:13+05:30"><meta property="og:site_name" content="qcentlabs"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://qcentlabs.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Making my own Programmer/Debugger using ARM SWD."><meta name=twitter:description content="So, recently at my day job our team needed to develop a PCB test JIG for mass manufacturing/testing of the assembled PCBs.
To increase the efficiency of this test process, the idea of testing and programming multiple boards at once came into my mind.
Initially I thought of using multiple Debuggers/Programmers to flash code into multiple boards at once, but as you know, most of these debuggers aren&rsquo;t cheap.
Except for ST-link V2 clones which are available at dirt cheap prices, all other debuggers cost at least 10s of dollars and from then on special mass production versions of J-link can go on for 1000s of dollars not including professional software that you need to purchase separately for flash programming in a manufacturing setting."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://qcentlabs.com/posts/"},{"@type":"ListItem","position":2,"name":"Making my own Programmer/Debugger using ARM SWD.","item":"http://qcentlabs.com/posts/swd_banger/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Making my own Programmer/Debugger using ARM SWD.","name":"Making my own Programmer\/Debugger using ARM SWD.","description":"So, recently at my day job our team needed to develop a PCB test JIG for mass manufacturing/testing of the assembled PCBs.\nTo increase the efficiency of this test process, the idea of testing and programming multiple boards at once came into my mind.\nInitially I thought of using multiple Debuggers/Programmers to flash code into multiple boards at once, but as you know, most of these debuggers aren\u0026rsquo;t cheap.\nExcept for ST-link V2 clones which are available at dirt cheap prices, all other debuggers cost at least 10s of dollars and from then on special mass production versions of J-link can go on for 1000s of dollars not including professional software that you need to purchase separately for flash programming in a manufacturing setting.","keywords":[],"articleBody":"So, recently at my day job our team needed to develop a PCB test JIG for mass manufacturing/testing of the assembled PCBs.\nTo increase the efficiency of this test process, the idea of testing and programming multiple boards at once came into my mind.\nInitially I thought of using multiple Debuggers/Programmers to flash code into multiple boards at once, but as you know, most of these debuggers aren’t cheap.\nExcept for ST-link V2 clones which are available at dirt cheap prices, all other debuggers cost at least 10s of dollars and from then on special mass production versions of J-link can go on for 1000s of dollars not including professional software that you need to purchase separately for flash programming in a manufacturing setting.\nSo i though well, it’s time to dig into ARMs SWD protocol myself and make my own debugger/programmer :)\n“A Raspberry Pi Pico being used to program 3 STM32 blue pills at once without the need for any external HOST computer, the firmware to upload is stored in pi pico’s internal flash.”\nWhat exactly is this JTAG/SWD stuff anyways? JTAG stands for Joint Test Action Group, these are the people who came up with the industry standard for verifying designs and testing of PCBs after they have been manufactured, and that standard is also named JTAG.\nDevices (MCUs/SoCs/MPUs) that have JTAG support can give an external tool(debugger/programmer) access to their internal system buses so that they can access all the system resources the same way the internal processor can.\nJTAG can also provide other useful features such as boundary scanning, which allows the external tool to directly probe the state of any pins of the device which can be useful to test the system after it has been manufactured.\nJTAG, being an industry standard can be used on almost any CPU architecture(or FPGA) depending on whether the manufacturer of the SoC has added support for it or not.\nSWD or Serial Wire Debug is a debugging interface specifically designed by ARM ltd as a part of it’s CoreSight Debugging and Trace architecture.\nIt was developed as a low pin count alternative to JTAG that allowed MCUs/MPUs/SoCs with ARMs Cortex-A/M/R cores to be debugged and provides real-time trace capabilities.\nThe major problem with JTAG for Microcontrollers was the minimum pin count of 4 (5 if reset was to be included).\nSmall MCUs with very low pin counts could not afford to give up 4 pins just for the debugging interface.\nFor basic debugging, SWD has the pin requirement of only 2 pins, one for CLOCK and another for DATA.\nIf you also want trace capabilities then depending on what method you choose (SWO vs ETM), it can require as low as 1 to as many as 38 extra pins.\nThe Hardware For this demo, we will be using a raspberry pi pico as our development platform to make our debugger/programmer, simply because its cheap and readily available.\nFor the target we will use a STM32 blue pill featuring the infamous STM32F103C8T6 microcontroller.\nFor the DSO to debug the physical layer we will be using the RIGOL 1054Z.\nJust to be clear, HOST refers to the debugger and TARGET refers to the device being debugged.\nSo, lets begin.\nThe PHY layer As mentioned above, SWD requires at least 2 pins to function, a CLOCK pin (SWDCLK) and a DATA pin (SWDIO).\nThe HOST is the only one that drives the CLOCK pin.\nThe DATA pin can be driven by both the HOST and the TARGET.\nThe CLOCK pin can have a pull down resistor although it isn’t compulsory, it’s a good practice, as it attenuates spurious signals when the pin is floating (debugger disconnected).\nThe DATA pin, if you are using it as an open-drain output must feature a pull-up resistor or else the line capacitance will be enough to corrupt the signal at faster clocks.\nA logic HIGH is interpreted as a ‘1’ and a logic LOW is interpreted as ‘0’ on DATA and CLOCK lines.\nThe Architecture SWD just like JTAG enables an external tool (the debugger) to get access to internal components of an MCU/MPU/SoC.\nThis might include access to the internal buses, special tracing and profiling components such as DWT,ITM and ETM etc.,\nSo how does this happen?\nWhen you connect you SWD enabled debugger to your MCU/MPU/SoC (from here on referred to as TARGET) via the SWD pins exposed by the said TARGET..\nYou connect to a component inside the TARGET called DAP or Debug Access Port.\nThe DAP is named so because it consists of 2 components, the Debug Port and the Access Port(s).\nThe Debug Port is the main interface that is connected to the external SWD pins and allows access to the internal structure of the ARM Debug Interface.\nAccess to various components inside the TARGET are provided in form of Access Ports or APs.\nThe DP acts as the master with multiple slave APs connected to it.\nBoth DP and AP have internal memory mapped registers which can be accessed by the external debugger.\nAccess to the DP registers is termed as Debug Port Access (DPACC).\nAccess to the AP registers is termed as Access Port Access (APACC).\nThe Protocol The SWD protocol is based on transactions.\nEvery transaction consists of 3 phases:\nA host to target packet request A target to host packet response. A data transfer phase, if required, either from host to target or vice-versa depending on the request made in phase 1. The host initialises any transation with the following packet structure:\ntypedef struct _swd_req { uint8_t start : 1; // This bit is always 1 uint8_t APnDP : 1; // This bis it 0 for DPACC and 1 for APACC uint8_t RnW : 1; // This bit is 0 for Write and 1 for Read uint8_t A : 2; // Has different meaning based on if AP is selected or DP. uint8_t parity : 1; // This parity check is done on APnDP,RnW,A bits; If no of 1s is even, parity is 0 uint8_t stop : 1; // This bit must be 0 for synchronous SWD, which means always. uint8_t park : 1; // This bit must be 1. } swd_req; The main things to notice here are the APnDP bit, the RnW bit and the A[2:3] bits.\nThe APnDP bit allows us to select whether we want to access the DP registers or the AP registers. The RnW bit allows us to specify whether this is a read or write request. The A bits are important as these form a part the address of the register to access within the DP or AP. For the DP, the address of the register you want to access is formed in the following way:\nThe Address of the DP registers is a 4bit value.\nThe A bits provide the upper 2 bits for this address, the lower 2 bits are always 0.\nThus the only possible values for the register address for the DP/AP are 0x0,0x4,0x8 and 0xC.\nDepending on the state of the RnW bit, and the 4 bit address formed using the A bits, you can select the DP registers you want to access.\nSome of these DP registers are read-only, some are write-only and only the CTRL/STAT is both read/write capable.\nLets see what some of these registers are:\nIDCODE Register: This register is always present on all DP implementations.\nIt provides identification information about the Debug Interface.\nThis is a read-only register and is always accessible, it is the first register the debugger reads when it connects to the TARGET.\nThis register defines the (DESIGNER), its part number(constant defined by ARM) and the version number.\nThe DESIGNER field is set by the SoC vendor in the RTL and is usually the assigned JEDEC Manufacturer ID.\nThe part number is a constant value set by ARM and is either 0xBA00 or 0xBA10.\nThe version number is also set by the SoC vendor and is used to differentiate between different products by the same vendor.\nThus using the IDCODE you can uniquely identify any SoC (If the vendor did his job right).\nABORT Register: This register is always present on all DP implementations.\nIt provides the external debugger the ability to force abort any ongoing transaction.\nThis is a write-only register and is always accessible.\nThis register also gives the ability to clear any sticky error flags that are set when any fault occurs in the protocol.\nCTRL/STAT Register: This register is always present on all DP implementations.\nIts provides control of the DP, and status information about the DP.\nIt is a read-write register, although some bits are read-only.\nThe bits of interest of us in this are the CSYSPWRUPREQ bit and the CDBGPWRUPREQ bit.\nThe DAP power domain model lists 3 major power domains:\nAlways-on power domain. System power domain. Debug power domain. The DP registers reside in the always-on power domain, thus they are always available even if the rest of the system is in power down/sleep mode.\nThe rest of the debug system and the core system can go in power down mode in which state we cannot access it via the APs.\nSetting the CSYSPWRUPREQ bit and the CDBGPWRUPREQ bit signals these domains to power back up so that the debug system can access them.\nCSYSPWRUPACK bit and the CDBGPWRUPACK bit return the response of this request, if successful these are read back as 1.\nRDBUFF Register: This register is always present on all DP implementations.\nThis is a read-only register.\nOn a SW-DP, performing a read of the Read Buffer captures data from the AP, presented as the result of a previous read, without initiating a new AP transaction.\nThis means that reading the Read Buffer returns the result of the last AP read access, without generating a new AP access.\nRESEND Register: This register is always present on all DP implementations.\nThis is a write-only register.\nIts purpose is to enable the read data to be recovered from a corrupted debugger transfer, without repeating the original AP transfer.\nSELECT Register: This register is always present on all DP implementations.\nIts main purpose is to select the current Access Port (AP) and the active four-word register bank within that AP.\nThis is a write-only register.\nAs of now, we have only been accessing DP registers, For accessing the AP registers, things are a bit complicated.\nAs you would remember, the APnDP bit of the SwD request packet selects whether the request to read/write data is for a DP or a AP.\nAlthough there is only one DP, there can be many APs connected as slave to that DP, so how do we select which of these APs we want to read/write to?\nSimple! by this SELECT register. The value of APSEL bits selects which AP we want to access.\nFurthermore, each AP can have multiple banks, each bank has 4 registers which can be selected by the A[3:2] bits of the swd request packet header.\nThese banks are selected by the APBANKSEL bits of the SELECT register, thus the APBANKSEL bits act as the A[7:4] bits, and the A[1:0] bits are always 0.\nThus each AP can have a total of 16 banks each with 4 registers so a total of 64 registers per AP.\nThese APs reside in a dedicated memory mapped 4KB address range but in that range ony 64 registers (32bit each) are accessible for a total of 256 Bytes.\nThis 4KB block of dedicated memory per AP is known as the Debug Register File.\nStitching this all together we get something like this:\nComing back to the protocol…\nAfter the initial host-to-target packet request, there is a turnaround cycle after which the control of SWDIO line is released by the HOST and is given over to the TARGET.\nThe TARGET then returns a 3 bit acknowledgement.\nThis response can be:\n0b100 or OK response, this is given when the DP is ready for the data-phase and no errors have occurred. 0b010 or WAIT response, this is given when there is a pending AP transaction going on. 0b001 or FAULT response, this is given when there is a sticky error flag set or when there was a issue in DATA format of previous transaction or a turnaround was missing. 0b111 or PROTOCOL error response, this is given when either there is no TARGET connected (as the line is PULLED UP), or there is an error in the packet headers (incorrect parity). After the ACK by TARGET there is another turnaround period if the request was to write data, the HOST then writes a 32 bit data packet + 1 parity bit for data.\nIf the initial packet request was for a read then there is no turnaround after ACK and the TARGET returns a 32-bit data packet + 1 parity bit for data which is then followed by a turnaround giving the control of the bus back to the HOST.\nThe MEM-AP As ARM is a memory mapped architecture, once someone gets access to the system bus/dcode bus/AHBS, they more or less get access to the whole system including the core registers, code space, peripherals, any internal SRAM/TCM, any external memory and the system space(PPB bus).\nThis access to TARGETs internal busses for the debugger is provided by a special AP called MEM-AP.\nDepending on which arm cortex core you are connecting to, the MEM-AP can be essentially a AHB-AP/AHBD-AP/AXI-AP which connects to the systems bus-matrix’s salve port as a master giving us access to the rest of the system and the core (even TCM access via AHB-S).\nOnce we can access the TARGETs internal address space via MEM-AP, we can:\nAccess the code space to view the contents of the internal FLASH. Access the SRAM/TCM. Access processors core registers via System Space. Access any external memory that is memory mapped into the address space. Access Core Debug present in the System Space. Access any peripherals. Do almost anything that is possible via memory mapped registers. On many simple TARGETs, the AP at address 0x0 is the MEM-AP, although this is highly IMPLEMENTATION DEPENDENT.\nCheck the TRM of the TARGET to identify how the vendor has implemented the debug subsystem.\nIn the MEM-AP, the registers at bank 0 are the ones that are the most interesting.\nThe Bank-0 of MEM-AP contains the following registers:\nAt address 0x00 we have the Control and Status Word Register (CSW). The bits of interest to us are 29,25,[5:4] and [2:0].\nBits 29 and 25 must be set to grant the debugger privileged master access over the AHB-AP.\nAddrInc [5:4] bits must be set to 0b01, this enables auto increment support so that memory address in TAR can auto-increment for serial writes in DRW.\nSize [2:0] bits must be set to 0b010 to perform 32-bit access over AHB-AP.\nAt the address 0x04 we have the Transfer Address Register (TAR). This register holds the address in memory that we want to read from or write to.\nAt the address 0xC we have the Data Read Write Register (DRW). This register holds the value that we need to write at the address denoted by the TAR, or it contains the value at the address denoted by the TAR.\nTo read any memory address, load the address into TAR and then perform an AP read from DRW*.\nTo write to any memory address, load the address into TAR and perform an AP write to DRW.\n*For an AP read operation, you might need to get the value from RDBUFF in DP if the ACK is returned as a WAIT response.\nThe Magic Switch Before we proceed further, we should clear something up.\nExcept for TARGETs that have very low pin count, almost all provide both JTAG and SWD support for maximum flexibility.\nThis is possible because pins for SWD and JTAG are muxed togather, the TCK pin of JTAG also acts as the SWDCLK pin, similarly the TMS pin of JTAG also acts as the SWDIO pin.\nThis combination of JTAG and SWD is called a SWJ-DP (Serial Wire JTAG - Debug Port).\nBy default in most TARGETs the Debug Port is configured for JTAG, because we are writing a debugger/programmer for SWD, we somehow need to switch the DP to use SWD.\nTo do this we perform a special switching sequence.\nFirst we need to reset the currently selected DP (default JTAG-DP), this is done by sending 50 or more clocks while keeping SWDIO HIGH. Then we send a special 16-bit JTAG-to-SWD select sequence (0xE79E LSB first). Then we again reset the DP (now SW-DP) by sending 50 or more clocks while keeping SWDIO HIGH. Then we send 12 clocks with SWDIO LOW. Once we have done this, the SW-DP is ready to use.\nNote: According to the Coresight Components TRM, this SWJ-DP Switching Sequences is Deprecated and a new method using JTAGNSW pin is used, but as per real-world experimentation, this sequence still holds true for majority of the MCUs in the market, refer to the TRM for further info.\nThe part where the FUN starts…. So now the fun stuff starts as after getting the protocol stuff done, we can actually connect a TARGET to our pico and explore the DAP.\n-Important thing to note here that the security settings for the TARGET are set to default enabling full unrestricted debug access.-\nThe first thing to do after doing the switching and reset sequence it to read the IDCODE register.\nIf done right, this will look something like this:\nThe blue channel denotes the clock and yellow the data, the initial 4 segments denote the JTAG-to-SWD switching sequence, the last segment is IDCODE read from DP. Zoomed IDCODE packet request and the subsequent TARGET response.\nThe STM32F103C8T6 (STM32 blue pill) returns us a IDCODE value of 0x1ba01477.\nThen we need to write to the CTRL/STAT register of the DP and enable the CSYSPWRUPREQ and CDBGPWRUPREQ bits to bring the rest of the system online.\nThen we need to set the SELECT register such that APSEL is 0x0 and APBANKSEL is also 0x0, so SELECT is 0x00000000 to access the MEM-AP (for STM32F10XX).\nThen we need to set CSW register of MEM-AP to the value of 0x22000012, enabling privileged master access over AHB-AP, auto-increment for TAR and 32-bit IO over DRW.\nNow we can access the full memory address space exposed by our TARGET by simply selecting the address via TAR and reading/writing via DRW.\nLets start by dumping the FLASH.\nThe code space in ARMv7-M starts at 0x00000000, the FLASH is also aliased with this address so the reads from this will dump the FLASH.\n**** SWD PHY Initialised! ***** DAP: Setup DP and MEM-AP. IDCODE: 0x1ba01477 ACK: 1 CTRLSTAT_W: 0x50000000 ACK: 1 CTRLSTAT_R: 0xf0000000 ACK: 1 CSW_W: 0x22000012 ACK: 1 20002800 080028b5 08000c5d 08000c63 08000c69 08000c6f 08000c75 00000000 00000000 00000000 00000000 08000c7b 08000c87 00000000 08000c93 . . . . . Cool! So if there is no security enabled, we can dump the flash from the entire chip via our debugger.\nThe Core Debug Dumping flash is fun and all but we are building a debugger and a programmer here, so how does that work?\nLets begin with how debugging works in ARM CoreSight debug architecture.\n-This segment is meant for ARMv7-M, although parts of it might be valid for ARMv7-A/R and ARMv6-M.-\nBut first, what does it actually mean to debug something?\nA bug is a flaw in code (or a feature for some), to debug means to remove the flaw.\nAnd to do so we need to understand why the flaw was there in first place.\nThis process of understanding begins by analyzing how the code works one step at a time.\nStep by step we inspect what each instruction that our CPU core executes does, we also watch how the this changes the data that our code deals with.\nEventually we will reach the point of failure, we can then rectify the issue by fixing the broken code.\nMost of the times, this approach works, but sometimes, we need to have an understanding of the whole system to intuitively guess where the issue might be.\nAccording to our little story here:\nWe need a system that can halt a CPU. The system should be able to execute a single instruction and then halt again, so that we can view the changes that instruction made. (called single stepping) The system should let us see that data the CPU is working on. (core registers and SRAM) The system should let us give it a address so that when the control flow reaches that address, the CPU halts. (called a breakpoint) For Cortex-M, all of this (except for breakpoints) is done via a set of special registers memory mapped in the System Space in a region referred to as Debug Control Block.\nThis functionality is called Core Debug.\nIn the grand scale of things, debugging can be divided into the following:\nInvasive Debugging:\nThis is the type of debugging which enables you to control and observe the processor and modify its state.\nOn ARMv7-M this can be divided into two more catagories:\nHalting Debug-mode\nThis is the typical debugging mode in which an external debugger is connected to the system which controls the debug flow, enabling it to halt the core and observe core registers and internal memory.\nMonitor Debug-mode\nThis is the type of debugging which enables a core to debug itself without any external debugger, this is possible due to a special DebugMon exception implemented in ARMv7-M.\nIn this type of debugging, the core isn’t halted on execution of a debug event, Instead a special exception is triggered (DebugMon) which can then be implemented in such a way that it observes the systems state to find the fault, this enables debugging in settings where halting the core can alter the natural system behavior.\nAlthough some performance impact is still observed due to the control flow switching to DebugMon Exception Handler.\nNon-Invasive Debugging:\nThis is the type of debugging which is done only by observing the processor.\nThis is most useful when you are debugging and performance profiling a real-time system and halting the core is not an option because it will alter the natural system behavior.\nThis is done by tracing and recording each and every instruction that the processor executes and the data it executed on, this data is collected in real-time without affecting the performance of the processor in any way.\nThe data is then analyzed later on to find the fault.\nIn ARMs CoreSight Debug Architecture, this functionality is provided by the ETM (Embedded Trace Macrocell) and ITM (Instrumentation Trace Macrocell).\nThese are not a part of the standard core and must be included separately in the system by your SoC vendor.\nIn this article we will only be focusing on Halting Debug mode as it is the traditional way most debuggers work.\nThe Core Debug (which provides Invasive-Debug functionality) contains the following 4 registers:\nAddress Name Access Function 0xE000EDF0 DHCSR RW Debug Halting Control and Status 0xE000EDF4 DCRSR WO Debug Core Register Selector 0xE000EDF8 DCRDR RW Debug Core Register Data 0xE000EDFC DEMCR RW Debug Exception and Monitor Control Lets have a look at what each of these do.\nDebug Halting Control and Status Register This is the main register that allows us to enable debugging support on a system.\nIt also contains key functionality to halt the core, single step it, mask special interrupts and report the status of the core.\nThe key things to note from the above figures are:\nAny Write to this register must be made with the upper half of the 32-bit word containing the DBGKEY 0xA05F.\nThis prevents accidental writes to this registers memory address from breaking the system.\nThe Halting-Debug mode can only be enabled by an external debugger via DAP (MEM-AP write).\nThis prevents any software running on the core to lock the system in a halted state.\nDebug Core Register Data Register This register is used to hold the value that needs to be written to an internal core register.\nIt also contains the value of an internal core register when a read request is made.\nIt can also be used as a temporary data cache to pass information between debugger and the firmware running on the core itself.\nDebug Core Register Selector Register This registers job is to select an internal core register to which we need to perform a read/write operation on.\nIt’s also a write-only register.\nTo write to an internal core register, we first put the value that we need to write into DCRDR, and then write to this register with the REGWnR bit set and the correct core register selected.\nTo read from an internal core register, we write to DCRSR with the REGWnR bit set to 0 and the correct core register selected, then the DCRDR can be read to get the value of the internal core register.\nDebug Exception and Monitor Control Register This register is primarily used for Monitor-Debug functionality and Vector Catch functionality that controls behavior of debug system on an exception generated due to faults.\nIt also has TRACENA bit which is used to enable ITM and DWT features if present.\nThe most important bit for us however, is the VC_CORERESET bit.\nThis bit allows us to catch the Reset Vector, i.e it will halt the Cortex-M core and enter the system into debug state when the system is reset by a Local Reset with the PC[R15] pointing to the Reset_Handler.\nWe need this because we ideally want the system to be in a known state before we start to debug it.\nSetting this bit and then performing a Local Reset(via NVIC.AIRCR) will reset the core and hopefully rest of the system. (How much of the system is reset is IMPLEMENTATION DEFINED.)\nThus now we know how to:\nHalt the core. (Set C_HALT + C_DEBUGEN in DHCSR) Single Step the halted core. (Set C_STEP + C_DEBUGEN in DHCSR) Read and Write to core registers. (Use DCRDC and DCRSR) Halt the core after Reset. (VC_CORERESET in DEMCR) To resume the core, just write 0 to both C_HALT and C_DEBUGEN.\nLet’s test this, to do that, lets make a simple program that we can debug.\nWhy not blink an LED? Its the Hello World equivalent in the embedded doamin. ;)\nWe will use assembly to write this as it is simple enough.\nHere we go, The reader must be familiar with Thumb-2 ISA to understand this, although I have kept it as simple as possible with added comments.\n.syntax unified .global blink_main .thumb .align 2 .equ FLASH_ACR,0x40022000 .equ FLASH_PRFTBE,0x10 .equ SYSTICK_CTRL,0xE000E010 .equ SYSTICK_LOAD,0xE000E014 .equ SYSTICK_VAL,0xE000E018 .equ SYSTICK_DELAY,0x160000 .equ RCC_AB2ENR,0x40021018 .equ RCC_AB2ENR_IOPCEN,0x10 .equ GPIOC_CRH,0x40011004 .equ GPIOC_BSSR,0x40011010 .equ GPIOC_PIN13_SET,0x00002000 .equ GPIOC_PIN13_RESET,0x20000000 .section .text .word 0x20005000 .word blink_main + 1 .word NMI_Handler .word HardFault_Handler .fill 42,1,0 NMI_Handler: b NMI_Handler HardFault_Handler: b HardFault_Handler .align 2 blink_main: cpsid i #enable flash prefetch buffer ldr r0,=FLASH_ACR ldr r1,=FLASH_PRFTBE str r1,[r0] #enable GPIOC clock ldr r0,=RCC_AB2ENR ldr r1,=RCC_AB2ENR_IOPCEN ldr r2,[r0] orr r2,r1 str r2,[r0] #setup PC13 as push-pull output ldr r0,=GPIOC_CRH ldr r1,=0x200000 str r1,[r0] #set value for PIN13 ldr r0,=GPIOC_BSSR ldr r1,=GPIOC_PIN13_SET str r1,[r0] #setup SysTick for delay timing #set reload value of systick ldr r0,=SYSTICK_LOAD ldr r1,=SYSTICK_DELAY str r1,[r0] #use cpu clock as systick clock source,do not generate systick interrupts and start timer ldr r0,=SYSTICK_CTRL mov r1,0x5 str r1,[r0] #the main blink loop ldr r0,=GPIOC_BSSR ldr r1,=GPIOC_PIN13_RESET ldr r2,=GPIOC_PIN13_SET blink_loop: str r1,[r0] bl delay str r2,[r0] bl delay b blink_loop delay: push {r0-r2} ldr r0,=SYSTICK_VAL mov r1,0x1 str r1,[r0] mov r2,5 delay_loop: ldr r1,[r0] cmp r1,r2 bge delay_loop pop {r0-r2} bx lr Lets assemble it with the GNU ARM embedded toolchain.\narm-none-eabi-as blink.s -mcpu=cortex-m3 -c -o blink.o We will use a simple linker script to set the base address for our .text section.\nENTRY(blink_main) SECTIONS { . = 0x20000000; .text : ALIGN(4) { *(.text); } } And finally.. to get our bin.\narm-none-eabi-ld -o blink.elf blink.o -T link.ld \u0026\u0026 arm-none-eabi-objcopy -O binary blink.elf blink.bin We will use the xxd tool to generate a hex dump as a C array of our bin which we than then include on our debugger code running on Pi Pico.\nxxd -g4 -i blink.bin \u003e bin.h We can then use the MEM-AP to write this binary directly at the SRAM base.\nHere she goes….\n***** SWD PHY Initialised! ***** DAP: Setup DP and MEM-AP. IDCODE: 0x1ba01477 ACK: 1 CTRLSTAT_W: 0x50000000 ACK: 1 CTRLSTAT_R: 0xf0000000 ACK: 1 CSW_W: 0x22000012 ACK: 1 CPUID_R: 0x411fc231 ACK: 1 Core Debug: Read DHCSR DHCSR ADDR: 0xe000edf0 ACK: 1 DHCSR VALUE: 0x03090000 ACK: 1 Core Debug: Enable Debug Mode. DHCSR ADDR: 0xe000edf0 ACK: 1 DHCSR VALUE: 0xa05f0003 ACK: 1 Core Debug: Read DHCSR DHCSR ADDR: 0xe000edf0 ACK: 1 DHCSR VALUE: 0x00030003 ACK: 1 Core Debug: Enable Halt on Reset DEMCR ADDR: 0xe000edfc ACK: 1 DEMCR VALUE: 0x00000001 ACK: 1 NVIC.AIRCR: Issue SYSRESET. AIRCR ADDR: 0xe000ed0c ACK: 1 AIRCR VALUE: 0xfa050004 ACK: 1 Core Debug: Read DHCSR DHCSR ADDR: 0xe000edf0 ACK: 1 DHCSR VALUE: 0x00030003 ACK: 1 Core Debug: Setup PC DCRDR ADDR: 0xe000edf8 ACK: 1 DCRDR VALUE: 0x20000119 ACK: 1 DCRSR ADDR: 0xe000edf4 ACK: 1 DCRSR VALUE: 0x0001000f ACK: 1 Core Debug: Setup MSP DCRDR ADDR: 0xe000edf8 ACK: 1 DCRDR VALUE: 0x20004000 ACK: 1 DCRSR ADDR: 0xe000edf4 ACK: 1 DCRSR VALUE: 0x0001000d ACK: 1 VTOR: Relocate VTOR to SRAM VTOR ADDR: 0xe000ed08 ACK: 1 VTOR VALUE: 0x20000000 ACK: 1 Writing bin to RAM CODE : 0x0 0x20005000 CODE : 0x4 0x20000118 CODE : 0x8 0x20000110 CODE : 0xc 0x20000112 CODE : 0x10 0x20000116 CODE : 0x14 0x20000116 CODE : 0x18 0x20000116 CODE : 0x1c 0x00000000 CODE : 0x20 0x00000000 CODE : 0x24 0x00000000 CODE : 0x28 0x00000000 CODE : 0x2c 0x20000116 CODE : 0x30 0x20000116 CODE : 0x34 0x00000000 CODE : 0x38 0x20000116 CODE : 0x3c 0x20000114 CODE : 0x40 0x00000000 CODE : 0x44 0x00000000 CODE : 0x48 0x00000000 CODE : 0x4c 0x00000000 CODE : 0x50 0x00000000 CODE : 0x54 0x00000000 CODE : 0x58 0x00000000 CODE : 0x5c 0x00000000 CODE : 0x60 0x00000000 CODE : 0x64 0x00000000 CODE : 0x68 0x00000000 CODE : 0x6c 0x00000000 CODE : 0x70 0x00000000 CODE : 0x74 0x00000000 CODE : 0x78 0x00000000 CODE : 0x7c 0x00000000 CODE : 0x80 0x00000000 CODE : 0x84 0x00000000 CODE : 0x88 0x00000000 CODE : 0x8c 0x00000000 CODE : 0x90 0x00000000 CODE : 0x94 0x00000000 CODE : 0x98 0x00000000 CODE : 0x9c 0x00000000 CODE : 0xa0 0x00000000 CODE : 0xa4 0x00000000 CODE : 0xa8 0x00000000 CODE : 0xac 0x00000000 CODE : 0xb0 0x00000000 CODE : 0xb4 0x00000000 CODE : 0xb8 0x00000000 CODE : 0xbc 0x00000000 CODE : 0xc0 0x00000000 CODE : 0xc4 0x00000000 CODE : 0xc8 0x00000000 CODE : 0xcc 0x00000000 CODE : 0xd0 0x00000000 CODE : 0xd4 0x00000000 CODE : 0xd8 0x00000000 CODE : 0xdc 0x00000000 CODE : 0xe0 0x00000000 CODE : 0xe4 0x00000000 CODE : 0xe8 0x00000000 CODE : 0xec 0x00000000 CODE : 0xf0 0x00000000 CODE : 0xf4 0x00000000 CODE : 0xf8 0x00000000 CODE : 0xfc 0x00000000 CODE : 0x100 0x00000000 CODE : 0x104 0x00000000 CODE : 0x108 0x00000000 CODE : 0x10c 0x00000000 CODE : 0x110 0xe7fee7fe CODE : 0x114 0x4770e7fe CODE : 0x118 0x4817b672 CODE : 0x11c 0x0110f04f CODE : 0x120 0xea426802 CODE : 0x124 0x60020201 CODE : 0x128 0xf44f4814 CODE : 0x12c 0x60011100 CODE : 0x130 0xf44f4813 CODE : 0x134 0x60015100 CODE : 0x138 0xf06f4812 CODE : 0x13c 0x6001417f CODE : 0x140 0xf04f4811 CODE : 0x144 0x60010105 CODE : 0x148 0xf04f480d CODE : 0x14c 0xf44f5100 CODE : 0x150 0x60015200 CODE : 0x154 0xf804f000 CODE : 0x158 0xf0006002 CODE : 0x15c 0xe7f8f801 CODE : 0x160 0x480ab407 CODE : 0x164 0x31b0f44f CODE : 0x168 0xf04f6001 CODE : 0x16c 0x6801020a CODE : 0x170 0xdafc4291 CODE : 0x174 0x4770bc07 CODE : 0x178 0x40021018 CODE : 0x17c 0x40011004 CODE : 0x180 0x40011010 CODE : 0x184 0xe000e014 CODE : 0x188 0xe000e010 CODE : 0x18c 0xe000e018 Reading bin from RAM Verification Successful! Core Debug: Read DHCSR DHCSR VALUE: 0x00030003 ACK: 1 Core Debug: Disable Debug Mode and run core. DHCSR ADDR: 0xe000edf0 ACK: 1 DHCSR VALUE: 0xa05f0000 ACK: 1 Core Debug: Read DHCSR DHCSR VALUE: 0x01010000 ACK: 1 If you have done everything right then you will be greeted with a blinking onboard-LED on the STM32 blue pill. :)\nWe can now also test our debugger to single step the code and read the value of PC.\nDebugger Single Step Output. Disassembly of the SRAM code. PC : 0x20000118 PC : 0x2000011a PC : 0x2000011c PC : 0x20000120 PC : 0x20000122 PC : 0x20000126 PC : 0x20000128 PC : 0x2000012a PC : 0x2000012e PC : 0x20000130 PC : 0x20000132 PC : 0x20000136 PC : 0x20000138 PC : 0x2000013a PC : 0x2000013e PC : 0x20000140 PC : 0x20000142 PC : 0x20000146 PC : 0x20000148 PC : 0x2000014a PC : 0x2000014e PC : 0x20000152 PC : 0x20000154 PC : 0x20000160 PC : 0x20000162 PC : 0x20000164 PC : 0x20000168 PC : 0x2000016a PC : 0x2000016e PC : 0x20000170 PC : 0x20000172 PC : 0x2000016e PC : 0x20000170 PC : 0x20000172 PC : 0x2000016e PC : 0x20000170 PC : 0x20000172 PC : 0x2000016e PC : 0x20000170 PC : 0x20000172 PC : 0x2000016e PC : 0x20000170 PC : 0x20000172 . . . . . 20000118 : 20000118:\tb672 cpsid\ti 2000011a:\t4817 ldr\tr0, [pc, #92]\t; (20000178 ) 2000011c:\tf04f 0110 mov.w\tr1, #16 20000120:\t6802 ldr\tr2, [r0, #0] 20000122:\tea42 0201 orr.w\tr2, r2, r1 20000126:\t6002 str\tr2, [r0, #0] 20000128:\t4814 ldr\tr0, [pc, #80]\t; (2000017c ) 2000012a:\tf44f 1100 mov.w\tr1, #2097152\t; 0x200000 2000012e:\t6001 str\tr1, [r0, #0] 20000130:\t4813 ldr\tr0, [pc, #76]\t; (20000180 ) 20000132:\tf44f 5100 mov.w\tr1, #8192\t; 0x2000 20000136:\t6001 str\tr1, [r0, #0] 20000138:\t4812 ldr\tr0, [pc, #72]\t; (20000184 ) 2000013a:\tf06f 417f mvn.w\tr1, #4278190080\t; 0xff000000 2000013e:\t6001 str\tr1, [r0, #0] 20000140:\t4811 ldr\tr0, [pc, #68]\t; (20000188 ) 20000142:\tf04f 0105 mov.w\tr1, #5 20000146:\t6001 str\tr1, [r0, #0] 20000148:\t480d ldr\tr0, [pc, #52]\t; (20000180 ) 2000014a:\tf04f 5100 mov.w\tr1, #536870912\t; 0x20000000 2000014e:\tf44f 5200 mov.w\tr2, #8192\t; 0x2000 20000152 : 20000152:\t6001 str\tr1, [r0, #0] 20000154:\tf000 f804 bl\t20000160 20000158:\t6002 str\tr2, [r0, #0] 2000015a:\tf000 f801 bl\t20000160 2000015e:\te7f8 b.n\t20000152 20000160 : 20000160:\tb407 push\t{r0, r1, r2} 20000162:\t480a ldr\tr0, [pc, #40]\t; (2000018c ) 20000164:\tf44f 31b0 mov.w\tr1, #90112\t; 0x16000 20000168:\t6001 str\tr1, [r0, #0] 2000016a:\tf04f 020a mov.w\tr2, #10 2000016e : 2000016e:\t6801 ldr\tr1, [r0, #0] 20000170:\t4291 cmp\tr1, r2 20000172:\tdafc bge.n\t2000016e 20000174:\tbc07 pop\t{r0, r1, r2} 20000176:\t4770 bx\tlr 20000178:\t40021018 andmi\tr1, r2, r8, lsl r0 2000017c:\t40011004 andmi\tr1, r1, r4 20000180:\t40011010 andmi\tr1, r1, r0, lsl r0 20000184:\te000e014 and\tlr, r0, r4, lsl r0 20000188:\te000e010 and\tlr, r0, r0, lsl r0 2000018c:\te000e018 and\tlr, r0, r8, lsl r0 As you can see the control flow via single stepping matches the disassembly output.\nKey things to take care of when executing from SRAM are:\nReset_Handler address must have the 1st bit set to enable thumb-mode. The VTOR must be relocated to SRAM before resuming the core. The MSP must also be set along with the PC. BreakPoints! Now, lets wrap the debug section up by briefly talking about breakpoint.\nARMv7-M supports 2 types of breakpoints\nHard Breakpoints Soft Breakpoints. -Depending on the functionality of FPB unit implemented by the SoC vendor, either all or parts of the following are true.-\nHard Breakpoints are made possible by the FPB (Flash Patching and BreakPoint Unit).\nIt consists of registers which which act as comparators, You set them up with the value of PC where you want the breakpoint to be and as soon as the control reaches to the PC value, the PC is remapped to the address present in FP_REMAP register of FPB unit or to a bkpt instruction, which will eventually trigger a DebugMon exception.\nThere are about 2-8 comparators available in FPB, the actual value is IMPLEMENTATION DEFINED.\nSoft Breakpoints are make possible by the bkpt instuction of ARMv7-M.\nDepeding on how things are set up, as soon as control reaches this instruction, the CPU enters debug state by entering the DebugMon exeption.\nWhy don’t you just FLASH them? This is the final part of this article and the only remaining quest of our journey.\nWe have learned about SWD, How debugging works, how to make, run and debug our own firmware via our own debugger.\nThe only thing that remains is the question of how does FLASH programming works?\nThis is where things get messy.\nUnlike the other stuff that we have mentioned above, FLASH programming in ARM ecosystem is completely non-standardised.\nIt is upto the job of the SoC vendor to define the specifics of how their system enables this process to happen.\nThis is why we see every SoC vendor provide their own tools and debuggers/programmers.\nST has ST-link, NXP has LPC-link/MCU-link, TI, SiLabs, Atmel everyone has their own way.\nThis is good as it provides flexibility for SoC vendors, Its also bad for us because making a universal programmer is now a very difficult job.\nThere are companies out there that actualy spend time and money over this and have made a hugely succesful business out of it. (SEGGER)\nBut still some of the ways this process happens are listed below:\nManually Program the FLASH using MEM-AP to access whatever FLASH programming peripheral is implemented in the SoC. Upload a FLASHLOADER and binary to SRAM and use it to access the FLASH programming peripheral and FLASH the binary. Use any helper functions implemented inside the ROM to program the flash. Out of these, 1st method is the slowest as it is dependent on the speed at which you can transact over SWD.\n2nd method is the most used followed by 3rd method in some cases.\nWe will use the 2nd method.\nTo do this, We will program a special binary into the SRAM called the FLASHLOADER.\nThe job of the FLASHLOADER is to run on the target core and program its FLASH by accessing the internal memory mapped peripheral responsible to do so.\nThis FLASHLOADER can run at the speed that core can run natively thus is way faster that doing it manually via individual SWD MEM-AP transactions.\nThe program to upload is also put inside the SRAM, broken into smaller blocks depending on the size of the binary to FLASH.\nThe FLASHLOADER can then flash the part in SRAM, and then signal the debugger using any number of mechanisms.\nThe debugger can then upload the next block to program and then re-runs the FLASHLOADER, this happens until the whole binary is FLASHED.\nOn our TARGET (STM32F103) the FLASH programming is taken care of by the FPEC. (Flash Programming and Erase Controller)\nThe FLASHLOADER that I have used is shown below.\nIt uses R0,R1,R2 and R3 to pass the start address of flash,sram, size of block, to mass erase or not.\n.syntax unified .global flashloader .thumb .align 2 #Keys for unlocking access to FPEC(Flash Program and Erase Controller) on STM32F10XXX series. .equ FLASH_KEY1,\t0x45670123 .equ FLASH_KEY2,\t0xCDEF89AB #FPEC registers .equ FLASH_ACR,\t0x40022000 .equ FLASH_KEYR,\t0x40022004 .equ FLASH_OPTKEYR,\t0x40022008 .equ FLASH_SR,\t0x4002200C .equ FLASH_CR,\t0x40022010 .equ FLASH_AR,\t0x40022014 .equ FLASH_OBR,\t0x4002201C .equ FLASH_WRPR,\t0x40022020 .equ DEBUG_DCRDR,\t0xE000EDF8 .equ MAGIC_WORD, 0xD33DB33F .section .text .word 0x20004000 .word flashloader .word NMI_Handler .word HardFault_Handler NMI_Handler: b NMI_Handler HardFault_Handler: b HardFault_Handler flashloader: #disable interrupts cpsid i push {r0-r4} #unlock FPEC registers by writing the unlock sequence ldr r0,=FLASH_KEYR ldr r1,=FLASH_KEY1 ldr r2,=FLASH_KEY2 str r1,[r0] str r2,[r0] #wait for flash to be free from pending ops before proceeding, useful on sudden reset of debugger. bl busy_check pop {r0-r4} #r0 contains the start address of flash write operation #r1 contains the start address of data in SRAM #r2 contains the number of bytes to write, i.e the size of data #r3 contains whether the request is for only mass erase or for program. #check if mass erase only set. mov r8,0x1 cmp r8,r3 beq mass_erase #prepare r8 to host SRAM base + SRAM data mov r8,r1 add r8,r2 .align 2 program_loop: #set PG bit in flash control register. ldr r5,=FLASH_CR mov r6,0x1 strh r6,[r5] #load the data in SRAM at r1 into r5 ldr r5,[r1] #store lower half-word at the FLASH address given by r0 strh r5,[r0] bl busy_check #add 2 to the FLASH address. add r0,0x2 #set PG bit in flash control register. ldr r5,=FLASH_CR mov r6,0x1 strh r6,[r5] #shift upper half to lower ldr r5,[r1] lsr r5,r5,16 #store the upper half into the updated FLASH address strh r5,[r0] bl busy_check #add 2 to the FLASH address. add r0,0x2 #mov to the next word in SRAM add r1,0x4 cmp r8,r1 bne program_loop #signal to the debugger that we are done. ldr r0,=DEBUG_DCRDR ldr r1,=MAGIC_WORD str r1,[r0] b . .align 2 mass_erase: #start the erase operation. ldr r0,=FLASH_CR mov r1,0x4 str r1,[r0] ldr r1,[r0] orr r1,0x40 str r1,[r0] #wait for mass erase to complete bl busy_check #signal to the debugger that we are done. ldr r0,=DEBUG_DCRDR ldr r1,=MAGIC_WORD str r1,[r0] b . .align 2 busy_check: push {r0-r4} .align 2 bc_loop: ldr r0,=FLASH_SR ldr r1,[r0] mov r2,0x1 and r1,r2 beq bc_loop pop {r0-r4} bx lr The Gist of it all. If you have stayed this far then congratulations!\nYou now are familiar with:\nARM SWD PHY layer and protocol. How debugging works on ARMv7-M. Different methods used to Program FLASH. The last thing to explain is how this works in general tools and debuggers for example ST-link, MCU-link, J-link etc..\nAll of these debuggers mentioned above do the same things explained in this artitle.\nThe are just given the commands by your IDE running a GDB session.\nAll these manufacturers have their own client application running on a HOST computer.\nThis application communicates over USB/Ethernet to the debugger.\nThis application also sets up a GDB server running the GDB Remote Serial Protocol.\nOur IDEs GDB session then connects to this server as a remote target to actually sent commands for debugging which are then forwareded over USB/Ethernet to the actual physical debugger.\nThats it for today folks!\nI hope you learned someting out of this. :)\nReferences ARM Debug Interface v5 Architecture Specification\nCoreSign Components TRM\nARMv7-M Architecture Reference Manual\nARM Cortex-M3 TRM / ARM Cortex-M4 TRM / ARM Cortex-M7 TRM\nNXP Application Note AN11553\nSiLabs Application Note AN0062\nSTM32F10XX Reference Manual\nSTM32 PM0076 Programming Manual\n","wordCount":"7103","inLanguage":"en","datePublished":"2023-06-27T01:15:13+05:30","dateModified":"2023-06-27T01:15:13+05:30","author":{"@type":"Person","name":"magalsh64"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://qcentlabs.com/posts/swd_banger/"},"publisher":{"@type":"Organization","name":"qcentlabs","logo":{"@type":"ImageObject","url":"http://qcentlabs.com/logo.png"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=http://qcentlabs.com/ accesskey=h title="qcentlabs (Alt + H)">qcentlabs</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=http://qcentlabs.com/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://qcentlabs.com/>Home</a>&nbsp;»&nbsp;<a href=http://qcentlabs.com/posts/>Posts</a></div><h1 class=post-title>Making my own Programmer/Debugger using ARM SWD.</h1><div class=post-meta><span title='2023-06-27 01:15:13 +0530 IST'>June 27, 2023</span>&nbsp;·&nbsp;34 min&nbsp;·&nbsp;magalsh64</div></header><div class=post-content><p>So, recently at my day job our team needed to develop a PCB test JIG for mass manufacturing/testing of the assembled PCBs.</p><p>To increase the efficiency of this test process, the idea of testing and programming multiple boards at once came into my mind.</p><p>Initially I thought of using multiple Debuggers/Programmers to flash code into multiple boards at once, but as you know, most of these debuggers aren&rsquo;t cheap.</p><p>Except for ST-link V2 clones which are available at dirt cheap prices, all other debuggers cost at least 10s of dollars and from then on special mass production versions
of J-link can go on for 1000s of dollars not including professional software that you need to purchase separately for flash programming in a manufacturing setting.</p><p>So i though well, it&rsquo;s time to dig into ARMs SWD protocol myself and make my own debugger/programmer :)</p><center><video width=100% playsinline autoplay muted loop>
<source src=/videos/swd_demo.mov type=video/mp4></video></center><p><em>&ldquo;A Raspberry Pi Pico being used to program 3 STM32 blue pills at once without the need for any external HOST computer, the firmware to upload is stored in pi pico&rsquo;s internal flash.&rdquo;</em></p><br><h2 id=what-exactly-is-this-jtagswd-stuff-anyways>What exactly is this JTAG/SWD stuff anyways?<a hidden class=anchor aria-hidden=true href=#what-exactly-is-this-jtagswd-stuff-anyways>#</a></h2><p><strong>JTAG</strong> stands for <strong>Joint Test Action Group</strong>, these are the people who came up with the industry standard for verifying designs and testing of PCBs after they have been manufactured, and that standard is also named JTAG.</p><p>Devices (MCUs/SoCs/MPUs) that have JTAG support can give an external tool(debugger/programmer) access to their internal system buses so that they can access all the system resources the same way the internal processor can.</p><p>JTAG can also provide other useful features such as boundary scanning, which allows the external tool to directly probe the state of any pins of the device which can be useful to test
the system after it has been manufactured.</p><p>JTAG, being an industry standard can be used on almost any CPU architecture(or FPGA) depending on whether the manufacturer of the SoC has added support for it or not.</p><p><strong>SWD or Serial Wire Debug</strong> is a debugging interface specifically designed by ARM ltd as a part of it&rsquo;s CoreSight Debugging and Trace architecture.</p><p>It was developed as a low pin count alternative to JTAG that allowed MCUs/MPUs/SoCs with ARMs Cortex-A/M/R cores to be debugged and provides real-time trace capabilities.</p><p>The major problem with JTAG for Microcontrollers was the minimum pin count of 4 (5 if reset was to be included).</p><p>Small MCUs with very low pin counts could not afford to give up 4 pins just for the debugging interface.</p><p>For basic debugging, SWD has the pin requirement of only 2 pins, one for CLOCK and another for DATA.</p><p>If you also want trace capabilities then depending on what method you choose (SWO vs ETM), it can require as low as 1 to as many as 38 extra pins.</p><br><h2 id=the-hardware>The Hardware<a hidden class=anchor aria-hidden=true href=#the-hardware>#</a></h2><p>For this demo, we will be using a raspberry pi pico as our development platform to make our debugger/programmer, simply because its cheap and readily available.</p><p>For the target we will use a STM32 blue pill featuring the infamous STM32F103C8T6 microcontroller.</p><p>For the DSO to debug the physical layer we will be using the RIGOL 1054Z.</p><p>Just to be clear, HOST refers to the debugger and TARGET refers to the device being debugged.</p><p>So, lets begin.</p><br><h2 id=the-phy-layer>The PHY layer<a hidden class=anchor aria-hidden=true href=#the-phy-layer>#</a></h2><p>As mentioned above, SWD requires at least 2 pins to function, a CLOCK pin (SWDCLK) and a DATA pin (SWDIO).</p><p><img loading=lazy src=/images/swd_phy.png alt=swd_init></p><p>The HOST is the only one that drives the CLOCK pin.</p><p>The DATA pin can be driven by both the HOST and the TARGET.</p><p>The CLOCK pin can have a pull down resistor although it isn&rsquo;t compulsory, it&rsquo;s a good practice, as it attenuates spurious signals when the pin is floating (debugger disconnected).</p><p>The DATA pin, if you are using it as an open-drain output must feature a pull-up resistor or else the line capacitance will be enough to corrupt the signal at faster clocks.</p><p>A logic HIGH is interpreted as a &lsquo;1&rsquo; and a logic LOW is interpreted as &lsquo;0&rsquo; on DATA and CLOCK lines.</p><br><h2 id=the-architecture>The Architecture<a hidden class=anchor aria-hidden=true href=#the-architecture>#</a></h2><p>SWD just like JTAG enables an external tool (the debugger) to get access to internal components of an MCU/MPU/SoC.</p><p>This might include access to the internal buses, special tracing and profiling components such as DWT,ITM and ETM etc.,</p><p>So how does this happen?</p><p><img loading=lazy src=/images/swd_dap.png alt=swd_dap></p><p>When you connect you SWD enabled debugger to your MCU/MPU/SoC (from here on referred to as TARGET) via the SWD pins exposed by the said TARGET..</p><p>You connect to a component inside the TARGET called <strong>DAP</strong> or <strong>Debug Access Port</strong>.</p><p>The DAP is named so because it consists of 2 components, the Debug Port and the Access Port(s).</p><p>The Debug Port is the main interface that is connected to the external SWD pins and allows access to the internal structure of the ARM Debug Interface.</p><p>Access to various components inside the TARGET are provided in form of Access Ports or APs.</p><p>The DP acts as the master with multiple slave APs connected to it.</p><p>Both DP and AP have internal memory mapped registers which can be accessed by the external debugger.</p><ol><li><p>Access to the DP registers is termed as Debug Port Access (DPACC).</p></li><li><p>Access to the AP registers is termed as Access Port Access (APACC).</p></li></ol><br><h2 id=the-protocol>The Protocol<a hidden class=anchor aria-hidden=true href=#the-protocol>#</a></h2><p>The SWD protocol is based on transactions.</p><p>Every transaction consists of 3 phases:</p><ol><li>A host to target packet request</li><li>A target to host packet response.</li><li>A data transfer phase, if required, either from host to target or vice-versa depending on the request made in phase 1.</li></ol><p>The host initialises any transation with the following packet structure:</p><pre tabindex=0><code>typedef struct _swd_req
{
    uint8_t start : 1;  // This bit is always 1
    uint8_t APnDP : 1;  // This bis it 0 for DPACC and 1 for APACC
    uint8_t RnW : 1;    // This bit is 0 for Write and 1 for Read
    uint8_t A : 2;      // Has different meaning based on if AP is selected or DP.
    uint8_t parity : 1; // This parity check is done on APnDP,RnW,A bits; If no of 1s is even, parity is 0
    uint8_t stop : 1;   // This bit must be 0 for synchronous SWD, which means always.
    uint8_t park : 1;   // This bit must be 1.
} swd_req;
</code></pre><p>The main things to notice here are the APnDP bit, the RnW bit and the A[2:3] bits.</p><ol><li>The APnDP bit allows us to select whether we want to access the DP registers or the AP registers.</li><li>The RnW bit allows us to specify whether this is a read or write request.</li><li>The A bits are important as these form a part the address of the register to access within the DP or AP.</li></ol><p><img loading=lazy src=/images/swd_dp_regs.png alt=swd_dp_regs></p><p>For the DP, the address of the register you want to access is formed in the following way:</p><ol><li><p>The Address of the DP registers is a 4bit value.</p></li><li><p>The A bits provide the upper 2 bits for this address, the lower 2 bits are always 0.</p></li></ol><p>Thus the only possible values for the register address for the DP/AP are 0x0,0x4,0x8 and 0xC.</p><p>Depending on the state of the RnW bit, and the 4 bit address formed using the A bits, you can select the DP registers you want to access.</p><p>Some of these DP registers are read-only, some are write-only and only the CTRL/STAT is both read/write capable.</p><p>Lets see what some of these registers are:</p><h4 id=idcode-register>IDCODE Register:<a hidden class=anchor aria-hidden=true href=#idcode-register>#</a></h4><p>This register is always present on all DP implementations.</p><p>It provides identification information about the Debug Interface.</p><p>This is a read-only register and is always accessible, it is the first register the debugger reads when it connects to the TARGET.</p><p><img loading=lazy src=/images/swd_dp_idcode.png alt=swd_dp_idcode></p><p>This register defines the (DESIGNER), its part number(constant defined by ARM) and the version number.</p><p>The DESIGNER field is set by the SoC vendor in the RTL and is usually the assigned JEDEC Manufacturer ID.</p><p>The part number is a constant value set by ARM and is either 0xBA00 or 0xBA10.</p><p>The version number is also set by the SoC vendor and is used to differentiate between different products by the same vendor.</p><p>Thus using the IDCODE you can uniquely identify any SoC (If the vendor did his job right).</p><h4 id=abort-register>ABORT Register:<a hidden class=anchor aria-hidden=true href=#abort-register>#</a></h4><p>This register is always present on all DP implementations.</p><p>It provides the external debugger the ability to force abort any ongoing transaction.</p><p>This is a write-only register and is always accessible.</p><p><img loading=lazy src=/images/swd_dp_abort.png alt=swd_dp_abort></p><p>This register also gives the ability to clear any sticky error flags that are set when any fault occurs in the protocol.</p><h4 id=ctrlstat-register>CTRL/STAT Register:<a hidden class=anchor aria-hidden=true href=#ctrlstat-register>#</a></h4><p>This register is always present on all DP implementations.</p><p>Its provides control of the DP, and status information about the DP.</p><p>It is a read-write register, although some bits are read-only.</p><p><img loading=lazy src=/images/swd_dp_ctrlstat.png alt=swd_dp_crtlstat></p><p>The bits of interest of us in this are the CSYSPWRUPREQ bit and the CDBGPWRUPREQ bit.</p><p>The DAP power domain model lists 3 major power domains:</p><ol><li>Always-on power domain.</li><li>System power domain.</li><li>Debug power domain.</li></ol><p>The DP registers reside in the always-on power domain, thus they are always available even if the rest of the system is in power down/sleep mode.</p><p>The rest of the debug system and the core system can go in power down mode in which state we cannot access it via the APs.</p><p>Setting the CSYSPWRUPREQ bit and the CDBGPWRUPREQ bit signals these domains to power back up so that the debug system can access them.</p><p>CSYSPWRUPACK bit and the CDBGPWRUPACK bit return the response of this request, if successful these are read back as 1.</p><h4 id=rdbuff-register>RDBUFF Register:<a hidden class=anchor aria-hidden=true href=#rdbuff-register>#</a></h4><p>This register is always present on all DP implementations.</p><p>This is a read-only register.</p><p>On a SW-DP, performing a read of the Read Buffer captures data from the AP, presented as the result of a
previous read, without initiating a new AP transaction.</p><p>This means that reading the Read Buffer returns the result of the last AP read access, without generating a new AP access.</p><h4 id=resend-register>RESEND Register:<a hidden class=anchor aria-hidden=true href=#resend-register>#</a></h4><p>This register is always present on all DP implementations.</p><p>This is a write-only register.</p><p>Its purpose is to enable the read data to be recovered from a corrupted debugger transfer, without repeating the original AP transfer.</p><h4 id=select-register>SELECT Register:<a hidden class=anchor aria-hidden=true href=#select-register>#</a></h4><p>This register is always present on all DP implementations.</p><p>Its main purpose is to select the current Access Port (AP) and the active four-word register bank within that AP.</p><p>This is a write-only register.</p><p><img loading=lazy src=/images/swd_dp_select.png alt=swd_dp_select></p><p>As of now, we have only been accessing DP registers, For accessing the AP registers, things are a bit complicated.</p><p>As you would remember, the APnDP bit of the SwD request packet selects whether the request to read/write data is for a DP or a AP.</p><p>Although there is only one DP, there can be many APs connected as slave to that DP, so how do we select which of these APs we want to read/write to?</p><p>Simple! by this SELECT register. The value of APSEL bits selects which AP we want to access.</p><p>Furthermore, each AP can have multiple banks, each bank has 4 registers which can be selected by the A[3:2] bits of the swd request packet header.</p><p>These banks are selected by the APBANKSEL bits of the SELECT register, thus the APBANKSEL bits act as the A[7:4] bits, and the A[1:0] bits are always 0.</p><p>Thus each AP can have a total of 16 banks each with 4 registers so a total of 64 registers per AP.</p><p>These APs reside in a dedicated memory mapped 4KB address range but in that range ony 64 registers (32bit each) are accessible for a total of 256 Bytes.</p><p>This 4KB block of dedicated memory per AP is known as the <em>Debug Register File</em>.</p><p>Stitching this all together we get something like this:</p><p><img loading=lazy src=/images/swd_ap.png alt=swd_ap></p><br><p>Coming back to the protocol&mldr;</p><p>After the initial host-to-target packet request, there is a turnaround cycle after which the control of SWDIO line is released by the HOST and is given over to the TARGET.</p><p>The TARGET then returns a 3 bit acknowledgement.</p><p>This response can be:</p><ol><li>0b100 or OK response, this is given when the DP is ready for the data-phase and no errors have occurred.
<img loading=lazy src=/images/swd_ack_ok1.png alt=swd_ack_ok1>
<img loading=lazy src=/images/swd_ack_ok2.png alt=swd_ack_ok2></li><li>0b010 or WAIT response, this is given when there is a pending AP transaction going on.
<img loading=lazy src=/images/swd_ack_wait.png alt=swd_ack_wait></li><li>0b001 or FAULT response, this is given when there is a sticky error flag set or when there was a issue in DATA format of previous transaction or a turnaround was missing.
<img loading=lazy src=/images/swd_ack_fault.png alt=swd_ack_fault></li><li>0b111 or PROTOCOL error response, this is given when either there is no TARGET connected (as the line is PULLED UP), or there is an error in the packet headers (incorrect parity).
<img loading=lazy src=/images/swd_ack_error.png alt=swd_ack_error></li></ol><p>After the ACK by TARGET there is another turnaround period if the request was to write data, the HOST then writes a 32 bit data packet + 1 parity bit for data.</p><p>If the initial packet request was for a read then there is no turnaround after ACK and the TARGET returns a 32-bit data packet + 1 parity bit for data which is then followed by a turnaround giving the control of the bus back to the HOST.</p><br><h2 id=the-mem-ap>The MEM-AP<a hidden class=anchor aria-hidden=true href=#the-mem-ap>#</a></h2><p>As ARM is a memory mapped architecture, once someone gets access to the system bus/dcode bus/AHBS, they more or less get access to the whole system including the core registers, code space, peripherals, any internal SRAM/TCM, any external memory and the system space(PPB bus).</p><p>This access to TARGETs internal busses for the debugger is provided by a special AP called MEM-AP.</p><p>Depending on which arm cortex core you are connecting to, the MEM-AP can be essentially a AHB-AP/AHBD-AP/AXI-AP which connects to the systems bus-matrix&rsquo;s salve port as a master giving us access to the rest of the system and the core (even TCM access via AHB-S).</p><p>Once we can access the TARGETs internal address space via MEM-AP, we can:</p><ol><li>Access the code space to view the contents of the internal FLASH.</li><li>Access the SRAM/TCM.</li><li>Access processors core registers via System Space.</li><li>Access any external memory that is memory mapped into the address space.</li><li>Access Core Debug present in the System Space.</li><li>Access any peripherals.</li><li>Do almost anything that is possible via memory mapped registers.</li></ol><p>On many simple TARGETs, the AP at address 0x0 is the MEM-AP, although this is highly IMPLEMENTATION DEPENDENT.</p><p>Check the TRM of the TARGET to identify how the vendor has implemented the debug subsystem.</p><p>In the MEM-AP, the registers at bank 0 are the ones that are the most interesting.</p><p>The Bank-0 of MEM-AP contains the following registers:</p><ol><li>At address 0x00 we have the Control and Status Word Register (CSW).</li></ol><p><img loading=lazy src=/images/swd_ap_csw.png alt=swd_ap_csw></p><p><img loading=lazy src=/images/swd_ap_csw_regs.png alt=swd_ap_csw></p><p>The bits of interest to us are 29,25,[5:4] and [2:0].</p><ul><li><p>Bits 29 and 25 must be set to grant the debugger privileged master access over the AHB-AP.</p></li><li><p>AddrInc [5:4] bits must be set to 0b01, this enables auto increment support so that memory address in TAR can auto-increment for serial writes in DRW.</p></li><li><p>Size [2:0] bits must be set to 0b010 to perform 32-bit access over AHB-AP.</p></li></ul><ol start=2><li>At the address 0x04 we have the Transfer Address Register (TAR).</li></ol><p>This register holds the address in memory that we want to read from or write to.</p><ol start=3><li>At the address 0xC we have the Data Read Write Register (DRW).</li></ol><p>This register holds the value that we need to write at the address denoted by the TAR, or it contains the value at the address denoted by the TAR.</p><p>To read any memory address, load the address into TAR and then perform an AP read from DRW*.</p><p>To write to any memory address, load the address into TAR and perform an AP write to DRW.</p><p>*<em>For an AP read operation, you might need to get the value from RDBUFF in DP if the ACK is returned as a WAIT response.</em></p><br><h2 id=the-magic-switch>The Magic Switch<a hidden class=anchor aria-hidden=true href=#the-magic-switch>#</a></h2><p>Before we proceed further, we should clear something up.</p><p>Except for TARGETs that have very low pin count, almost all provide both JTAG and SWD support for maximum flexibility.</p><p>This is possible because pins for SWD and JTAG are muxed togather,
the TCK pin of JTAG also acts as the SWDCLK pin, similarly the TMS pin of JTAG also acts as the SWDIO pin.</p><p>This combination of JTAG and SWD is called a SWJ-DP (Serial Wire JTAG - Debug Port).</p><p>By default in most TARGETs the Debug Port is configured for JTAG, because we are writing a debugger/programmer for SWD,
we somehow need to switch the DP to use SWD.</p><p>To do this we perform a special switching sequence.</p><ol><li>First we need to reset the currently selected DP (default JTAG-DP), this is done by sending 50 or more clocks while keeping SWDIO HIGH.</li></ol><p><img loading=lazy src=/images/swd_jt2swd_clk.png alt=swd_clk></p><ol start=2><li>Then we send a special 16-bit JTAG-to-SWD select sequence (0xE79E LSB first).</li></ol><p><img loading=lazy src=/images/swd_jt2swd_magic.png alt=swd_magic></p><ol start=3><li>Then we again reset the DP (now SW-DP) by sending 50 or more clocks while keeping SWDIO HIGH.</li></ol><p><img loading=lazy src=/images/swd_jt2swd_clk.png alt=swd_clk></p><ol start=4><li>Then we send 12 clocks with SWDIO LOW.</li></ol><p><img loading=lazy src=/images/swd_jt2swd_empty.png alt=swd_empty></p><p>Once we have done this, the SW-DP is ready to use.</p><p><em>Note: According to the Coresight Components TRM, this SWJ-DP Switching Sequences is Deprecated and a new method using JTAGNSW pin is used, but as per real-world experimentation, this sequence still holds true for majority of the MCUs in the market, refer to the TRM for further info.</em></p><h2 id=the-part-where-the-fun-starts>The part where the FUN starts&mldr;.<a hidden class=anchor aria-hidden=true href=#the-part-where-the-fun-starts>#</a></h2><p>So now the fun stuff starts as after getting the protocol stuff done, we can actually connect a TARGET to our pico and explore the DAP.</p><p><em>-Important thing to note here that the security settings for the TARGET are set to default enabling full unrestricted debug access.-</em></p><p>The first thing to do after doing the switching and reset sequence it to read the IDCODE register.</p><p>If done right, this will look something like this:</p><p><img loading=lazy src=/images/swd_init.png alt=swd_init>
<em>The blue channel denotes the clock and yellow the data, the initial 4 segments denote the JTAG-to-SWD switching sequence, the last segment is IDCODE read from DP.</em>
<img loading=lazy src=/images/swd_idcode.png alt=swd_idcode>
<em>Zoomed IDCODE packet request and the subsequent TARGET response.</em></p><p>The STM32F103C8T6 (STM32 blue pill) returns us a IDCODE value of 0x1ba01477.</p><p>Then we need to write to the CTRL/STAT register of the DP and enable the CSYSPWRUPREQ and CDBGPWRUPREQ bits to bring the rest of the system online.</p><p>Then we need to set the SELECT register such that APSEL is 0x0 and APBANKSEL is also 0x0, so SELECT is 0x00000000 to access the MEM-AP (for STM32F10XX).</p><p>Then we need to set CSW register of MEM-AP to the value of 0x22000012, enabling privileged master access over AHB-AP, auto-increment for TAR and 32-bit IO over DRW.</p><p>Now we can access the full memory address space exposed by our TARGET by simply selecting the address via TAR and reading/writing via DRW.</p><p>Lets start by dumping the FLASH.</p><p>The code space in ARMv7-M starts at 0x00000000, the FLASH is also aliased with this address so the reads from this will dump the FLASH.</p><pre tabindex=0><code>**** SWD PHY Initialised! *****

DAP: Setup DP and MEM-AP.
IDCODE: 0x1ba01477 ACK: 1
CTRLSTAT_W: 0x50000000 ACK: 1
CTRLSTAT_R: 0xf0000000 ACK: 1
CSW_W: 0x22000012 ACK: 1

20002800 
080028b5 
08000c5d 
08000c63 
08000c69 
08000c6f 
08000c75 
00000000 
00000000 
00000000 
00000000 
08000c7b 
08000c87 
00000000 
08000c93 
.
.
.
.
.
</code></pre><p>Cool! So if there is no security enabled, we can dump the flash from the entire chip via our debugger.</p><h2 id=the-core-debug>The Core Debug<a hidden class=anchor aria-hidden=true href=#the-core-debug>#</a></h2><p>Dumping flash is fun and all but we are building a debugger and a programmer here, so how does that work?</p><p>Lets begin with how debugging works in ARM CoreSight debug architecture.</p><p><em>-This segment is meant for ARMv7-M, although parts of it might be valid for ARMv7-A/R and ARMv6-M.-</em></p><br><p>But first, what does it actually mean to debug something?</p><p>A bug is a flaw in code (or a feature for some), to debug means to remove the flaw.</p><p>And to do so we need to understand why the flaw was there in first place.</p><p>This process of understanding begins by analyzing how the code works one step at a time.</p><p>Step by step we inspect what each instruction that our CPU core executes does, we also watch how the this changes the data that our code deals with.</p><p>Eventually we will reach the point of failure, we can then rectify the issue by fixing the broken code.</p><p>Most of the times, this approach works, but sometimes, we need to have an understanding of the whole system to intuitively guess where the issue might be.</p><p>According to our little story here:</p><ol><li>We need a system that can halt a CPU.</li><li>The system should be able to execute a single instruction and then halt again, so that we can view the changes that instruction made. (called single stepping)</li><li>The system should let us see that data the CPU is working on. (core registers and SRAM)</li><li>The system should let us give it a address so that when the control flow reaches that address, the CPU halts. (called a breakpoint)</li></ol><p>For Cortex-M, all of this (except for breakpoints) is done via a set of special registers memory mapped in the System Space in a region referred to as Debug Control Block.</p><p>This functionality is called <strong>Core Debug</strong>.</p><p>In the grand scale of things, debugging can be divided into the following:</p><ol><li><p><strong>Invasive Debugging</strong>:</p><p>This is the type of debugging which enables you to control and observe the processor and modify its state.</p><p>On ARMv7-M this can be divided into two more catagories:</p><ul><li><p>Halting Debug-mode</p><p>This is the typical debugging mode in which an external debugger is connected to the system which controls the debug flow, enabling it to halt the core and observe core
registers and internal memory.</p></li><li><p>Monitor Debug-mode</p><p>This is the type of debugging which enables a core to debug itself without any external debugger, this is possible due to a special DebugMon exception implemented in ARMv7-M.</p><p>In this type of debugging, the core isn&rsquo;t halted on execution of a debug event, Instead a special exception is triggered (DebugMon) which can then be implemented in such a way that it observes the systems state to find the fault, this enables debugging in settings where halting the core can alter the natural system behavior.</p><p>Although some performance impact is still observed due to the control flow switching to DebugMon Exception Handler.</p></li></ul></li><li><p><strong>Non-Invasive Debugging</strong>:</p><p>This is the type of debugging which is done only by observing the processor.</p><p>This is most useful when you are debugging and performance profiling a real-time system and halting the core is not an option because it will alter the natural system behavior.</p><p>This is done by tracing and recording each and every instruction that the processor executes and the data it executed on, this data is collected in real-time
without affecting the performance of the processor in any way.</p><p>The data is then analyzed later on to find the fault.</p><p>In ARMs CoreSight Debug Architecture, this functionality is provided by the ETM (Embedded Trace Macrocell) and ITM (Instrumentation Trace Macrocell).</p><p>These are not a part of the standard core and must be included separately in the system by your SoC vendor.</p></li></ol><p>In this article we will only be focusing on Halting Debug mode as it is the traditional way most debuggers work.</p><p>The <strong>Core Debug</strong> (which provides Invasive-Debug functionality) contains the following 4 registers:</p><table><thead><tr><th style=text-align:center><strong>Address</strong></th><th style=text-align:center><strong>Name</strong></th><th style=text-align:center><strong>Access</strong></th><th style=text-align:center><strong>Function</strong></th></tr></thead><tbody><tr><td style=text-align:center>0xE000EDF0</td><td style=text-align:center>DHCSR</td><td style=text-align:center>RW</td><td style=text-align:center>Debug Halting Control and Status</td></tr><tr><td style=text-align:center>0xE000EDF4</td><td style=text-align:center>DCRSR</td><td style=text-align:center>WO</td><td style=text-align:center>Debug Core Register Selector</td></tr><tr><td style=text-align:center>0xE000EDF8</td><td style=text-align:center>DCRDR</td><td style=text-align:center>RW</td><td style=text-align:center>Debug Core Register Data</td></tr><tr><td style=text-align:center>0xE000EDFC</td><td style=text-align:center>DEMCR</td><td style=text-align:center>RW</td><td style=text-align:center>Debug Exception and Monitor Control</td></tr></tbody></table><p>Lets have a look at what each of these do.</p><h4 id=debug-halting-control-and-status-register>Debug Halting Control and Status Register<a hidden class=anchor aria-hidden=true href=#debug-halting-control-and-status-register>#</a></h4><p>This is the main register that allows us to enable debugging support on a system.</p><p>It also contains key functionality to halt the core, single step it, mask special interrupts and report the status of the core.</p><p><img loading=lazy src=/images/swd_core_dhcsr.png alt=swd_core_dhcsr></p><p><img loading=lazy src=/images/swd_core_dhcsr_desc1.png alt=swd_core_dhcsr_desc1></p><p><img loading=lazy src=/images/swd_core_dhcsr_desc2.png alt=swd_core_dhcsr_desc2></p><p>The key things to note from the above figures are:</p><ul><li><p>Any Write to this register must be made with the upper half of the 32-bit word containing the DBGKEY 0xA05F.</p><p>This prevents accidental writes to this registers memory address from breaking the system.</p></li><li><p>The Halting-Debug mode can only be enabled by an external debugger via DAP (MEM-AP write).</p><p>This prevents any software running on the core to lock the system in a halted state.</p></li></ul><h4 id=debug-core-register-data-register>Debug Core Register Data Register<a hidden class=anchor aria-hidden=true href=#debug-core-register-data-register>#</a></h4><p>This register is used to hold the value that needs to be written to an internal core register.</p><p>It also contains the value of an internal core register when a read request is made.</p><p>It can also be used as a temporary data cache to pass information between debugger and the firmware running on the core itself.</p><h4 id=debug-core-register-selector-register>Debug Core Register Selector Register<a hidden class=anchor aria-hidden=true href=#debug-core-register-selector-register>#</a></h4><p>This registers job is to select an internal core register to which we need to perform a read/write operation on.</p><p>It&rsquo;s also a write-only register.</p><p><img loading=lazy src=/images/swd_core_dcrsr.png alt=swd_core_dcrsr></p><p><img loading=lazy src=/images/swd_core_dcrsr_desc.png alt=swd_core_dcrsr></p><p>To write to an internal core register, we first put the value that we need to write into DCRDR, and then write to this register with the REGWnR bit set and the correct core register selected.</p><p>To read from an internal core register, we write to DCRSR with the REGWnR bit set to 0 and the correct core register selected, then the DCRDR can be read to get the value of the internal core register.</p><h4 id=debug-exception-and-monitor-control-register>Debug Exception and Monitor Control Register<a hidden class=anchor aria-hidden=true href=#debug-exception-and-monitor-control-register>#</a></h4><p>This register is primarily used for Monitor-Debug functionality and Vector Catch functionality that controls behavior of debug system on an exception generated due to faults.</p><p>It also has TRACENA bit which is used to enable ITM and DWT features if present.</p><p><img loading=lazy src=/images/swd_core_dmecr.png alt=swd_core_dmecr></p><p>The most important bit for us however, is the VC_CORERESET bit.</p><p>This bit allows us to catch the Reset Vector, i.e it will halt the Cortex-M core and enter the system into debug state when the system is reset by a Local Reset with the PC[R15] pointing to the Reset_Handler.</p><p>We need this because we ideally want the system to be in a known state before we start to debug it.</p><p>Setting this bit and then performing a Local Reset(via NVIC.AIRCR) will reset the core and hopefully rest of the system. (How much of the system is reset is IMPLEMENTATION DEFINED.)</p><p>Thus now we know how to:</p><ol><li>Halt the core. (Set C_HALT + C_DEBUGEN in DHCSR)</li><li>Single Step the halted core. (Set C_STEP + C_DEBUGEN in DHCSR)</li><li>Read and Write to core registers. (Use DCRDC and DCRSR)</li><li>Halt the core after Reset. (VC_CORERESET in DEMCR)</li></ol><p>To resume the core, just write 0 to both C_HALT and C_DEBUGEN.</p><p>Let&rsquo;s test this, to do that, lets make a simple program that we can debug.</p><p>Why not blink an LED? Its the Hello World equivalent in the embedded doamin. ;)</p><p>We will use assembly to write this as it is simple enough.</p><p>Here we go, The reader must be familiar with Thumb-2 ISA to understand this, although I have kept it as simple as possible with added comments.</p><pre tabindex=0><code>.syntax unified

.global blink_main

.thumb

.align 2

.equ FLASH_ACR,0x40022000
.equ FLASH_PRFTBE,0x10

.equ SYSTICK_CTRL,0xE000E010
.equ SYSTICK_LOAD,0xE000E014
.equ SYSTICK_VAL,0xE000E018
.equ SYSTICK_DELAY,0x160000

.equ RCC_AB2ENR,0x40021018
.equ RCC_AB2ENR_IOPCEN,0x10

.equ GPIOC_CRH,0x40011004
.equ GPIOC_BSSR,0x40011010
.equ GPIOC_PIN13_SET,0x00002000
.equ GPIOC_PIN13_RESET,0x20000000


.section .text
.word 0x20005000
.word blink_main + 1
.word NMI_Handler
.word HardFault_Handler
.fill 42,1,0

NMI_Handler:
	b NMI_Handler

HardFault_Handler:
	b HardFault_Handler

.align 2
blink_main:
	cpsid i

	#enable flash prefetch buffer
	ldr r0,=FLASH_ACR
	ldr r1,=FLASH_PRFTBE
	str r1,[r0]

	#enable GPIOC clock
	ldr r0,=RCC_AB2ENR
	ldr r1,=RCC_AB2ENR_IOPCEN
	ldr r2,[r0]
	orr r2,r1
	str r2,[r0]

	#setup PC13 as push-pull output
	ldr r0,=GPIOC_CRH
	ldr r1,=0x200000
	str r1,[r0]

	#set value for PIN13
	ldr r0,=GPIOC_BSSR
	ldr r1,=GPIOC_PIN13_SET
	str r1,[r0]


	#setup SysTick for delay timing
	#set reload value of systick
	ldr r0,=SYSTICK_LOAD
	ldr r1,=SYSTICK_DELAY
	str r1,[r0]
	#use cpu clock as systick clock source,do not generate systick interrupts and start timer
	ldr r0,=SYSTICK_CTRL
	mov r1,0x5
	str r1,[r0]


	#the main blink loop
	ldr r0,=GPIOC_BSSR
	ldr r1,=GPIOC_PIN13_RESET
	ldr r2,=GPIOC_PIN13_SET
blink_loop:
	str r1,[r0]
	bl delay
	str r2,[r0]
	bl delay
	b blink_loop

delay:
	push {r0-r2}
	ldr r0,=SYSTICK_VAL
	mov r1,0x1
	str r1,[r0]
	mov r2,5
delay_loop:
	ldr r1,[r0]
	cmp r1,r2
	bge delay_loop
	pop {r0-r2}
	bx lr
</code></pre><p>Lets assemble it with the GNU ARM embedded toolchain.</p><pre tabindex=0><code>arm-none-eabi-as blink.s -mcpu=cortex-m3 -c -o blink.o 
</code></pre><p>We will use a simple linker script to set the base address for our .text section.</p><pre tabindex=0><code>ENTRY(blink_main)

SECTIONS
{
    . = 0x20000000;
    .text : ALIGN(4)
    { 
        *(.text); 
    }
}
</code></pre><p>And finally.. to get our bin.</p><pre tabindex=0><code>arm-none-eabi-ld -o blink.elf blink.o -T link.ld &amp;&amp; arm-none-eabi-objcopy -O binary blink.elf blink.bin
</code></pre><p>We will use the xxd tool to generate a hex dump as a C array of our bin which we than then include on our debugger code running on Pi Pico.</p><pre tabindex=0><code>xxd -g4 -i blink.bin &gt; bin.h
</code></pre><p>We can then use the MEM-AP to write this binary directly at the SRAM base.</p><p>Here she goes&mldr;.</p><pre tabindex=0><code>***** SWD PHY Initialised! *****

DAP: Setup DP and MEM-AP.
IDCODE: 0x1ba01477 ACK: 1
CTRLSTAT_W: 0x50000000 ACK: 1
CTRLSTAT_R: 0xf0000000 ACK: 1
CSW_W: 0x22000012 ACK: 1
CPUID_R: 0x411fc231 ACK: 1

Core Debug: Read DHCSR
DHCSR ADDR: 0xe000edf0 ACK: 1
DHCSR VALUE: 0x03090000 ACK: 1

Core Debug: Enable Debug Mode.
DHCSR ADDR: 0xe000edf0 ACK: 1
DHCSR VALUE: 0xa05f0003 ACK: 1

Core Debug: Read DHCSR
DHCSR ADDR: 0xe000edf0 ACK: 1
DHCSR VALUE: 0x00030003 ACK: 1

Core Debug: Enable Halt on Reset
DEMCR ADDR: 0xe000edfc ACK: 1
DEMCR VALUE: 0x00000001 ACK: 1

NVIC.AIRCR: Issue SYSRESET.
AIRCR ADDR: 0xe000ed0c ACK: 1
AIRCR VALUE: 0xfa050004 ACK: 1

Core Debug: Read DHCSR
DHCSR ADDR: 0xe000edf0 ACK: 1
DHCSR VALUE: 0x00030003 ACK: 1

Core Debug: Setup PC
DCRDR ADDR: 0xe000edf8 ACK: 1
DCRDR VALUE: 0x20000119 ACK: 1
DCRSR ADDR: 0xe000edf4 ACK: 1
DCRSR VALUE: 0x0001000f ACK: 1

Core Debug: Setup MSP
DCRDR ADDR: 0xe000edf8 ACK: 1
DCRDR VALUE: 0x20004000 ACK: 1
DCRSR ADDR: 0xe000edf4 ACK: 1
DCRSR VALUE: 0x0001000d ACK: 1

VTOR: Relocate VTOR to SRAM
VTOR ADDR: 0xe000ed08 ACK: 1
VTOR VALUE: 0x20000000 ACK: 1

Writing bin to RAM
CODE : 0x0 0x20005000
CODE : 0x4 0x20000118
CODE : 0x8 0x20000110
CODE : 0xc 0x20000112
CODE : 0x10 0x20000116
CODE : 0x14 0x20000116
CODE : 0x18 0x20000116
CODE : 0x1c 0x00000000
CODE : 0x20 0x00000000
CODE : 0x24 0x00000000
CODE : 0x28 0x00000000
CODE : 0x2c 0x20000116
CODE : 0x30 0x20000116
CODE : 0x34 0x00000000
CODE : 0x38 0x20000116
CODE : 0x3c 0x20000114
CODE : 0x40 0x00000000
CODE : 0x44 0x00000000
CODE : 0x48 0x00000000
CODE : 0x4c 0x00000000
CODE : 0x50 0x00000000
CODE : 0x54 0x00000000
CODE : 0x58 0x00000000
CODE : 0x5c 0x00000000
CODE : 0x60 0x00000000
CODE : 0x64 0x00000000
CODE : 0x68 0x00000000
CODE : 0x6c 0x00000000
CODE : 0x70 0x00000000
CODE : 0x74 0x00000000
CODE : 0x78 0x00000000
CODE : 0x7c 0x00000000
CODE : 0x80 0x00000000
CODE : 0x84 0x00000000
CODE : 0x88 0x00000000
CODE : 0x8c 0x00000000
CODE : 0x90 0x00000000
CODE : 0x94 0x00000000
CODE : 0x98 0x00000000
CODE : 0x9c 0x00000000
CODE : 0xa0 0x00000000
CODE : 0xa4 0x00000000
CODE : 0xa8 0x00000000
CODE : 0xac 0x00000000
CODE : 0xb0 0x00000000
CODE : 0xb4 0x00000000
CODE : 0xb8 0x00000000
CODE : 0xbc 0x00000000
CODE : 0xc0 0x00000000
CODE : 0xc4 0x00000000
CODE : 0xc8 0x00000000
CODE : 0xcc 0x00000000
CODE : 0xd0 0x00000000
CODE : 0xd4 0x00000000
CODE : 0xd8 0x00000000
CODE : 0xdc 0x00000000
CODE : 0xe0 0x00000000
CODE : 0xe4 0x00000000
CODE : 0xe8 0x00000000
CODE : 0xec 0x00000000
CODE : 0xf0 0x00000000
CODE : 0xf4 0x00000000
CODE : 0xf8 0x00000000
CODE : 0xfc 0x00000000
CODE : 0x100 0x00000000
CODE : 0x104 0x00000000
CODE : 0x108 0x00000000
CODE : 0x10c 0x00000000
CODE : 0x110 0xe7fee7fe
CODE : 0x114 0x4770e7fe
CODE : 0x118 0x4817b672
CODE : 0x11c 0x0110f04f
CODE : 0x120 0xea426802
CODE : 0x124 0x60020201
CODE : 0x128 0xf44f4814
CODE : 0x12c 0x60011100
CODE : 0x130 0xf44f4813
CODE : 0x134 0x60015100
CODE : 0x138 0xf06f4812
CODE : 0x13c 0x6001417f
CODE : 0x140 0xf04f4811
CODE : 0x144 0x60010105
CODE : 0x148 0xf04f480d
CODE : 0x14c 0xf44f5100
CODE : 0x150 0x60015200
CODE : 0x154 0xf804f000
CODE : 0x158 0xf0006002
CODE : 0x15c 0xe7f8f801
CODE : 0x160 0x480ab407
CODE : 0x164 0x31b0f44f
CODE : 0x168 0xf04f6001
CODE : 0x16c 0x6801020a
CODE : 0x170 0xdafc4291
CODE : 0x174 0x4770bc07
CODE : 0x178 0x40021018
CODE : 0x17c 0x40011004
CODE : 0x180 0x40011010
CODE : 0x184 0xe000e014
CODE : 0x188 0xe000e010
CODE : 0x18c 0xe000e018

Reading bin from RAM

Verification Successful!

Core Debug: Read DHCSR
DHCSR VALUE: 0x00030003 ACK: 1

Core Debug: Disable Debug Mode and run core.
DHCSR ADDR: 0xe000edf0 ACK: 1
DHCSR VALUE: 0xa05f0000 ACK: 1

Core Debug: Read DHCSR
DHCSR VALUE: 0x01010000 ACK: 1
</code></pre><p>If you have done everything right then you will be greeted with a blinking onboard-LED on the STM32 blue pill. :)</p><p>We can now also test our debugger to single step the code and read the value of PC.</p><table><tr><th>Debugger Single Step Output.</th><th>Disassembly of the SRAM code.</th></tr><tr><td><pre tabindex=0><code>PC : 0x20000118
PC : 0x2000011a
PC : 0x2000011c
PC : 0x20000120
PC : 0x20000122
PC : 0x20000126
PC : 0x20000128
PC : 0x2000012a
PC : 0x2000012e
PC : 0x20000130
PC : 0x20000132
PC : 0x20000136
PC : 0x20000138
PC : 0x2000013a
PC : 0x2000013e
PC : 0x20000140
PC : 0x20000142
PC : 0x20000146
PC : 0x20000148
PC : 0x2000014a
PC : 0x2000014e
PC : 0x20000152
PC : 0x20000154
PC : 0x20000160
PC : 0x20000162
PC : 0x20000164
PC : 0x20000168
PC : 0x2000016a
PC : 0x2000016e
PC : 0x20000170
PC : 0x20000172
PC : 0x2000016e
PC : 0x20000170
PC : 0x20000172
PC : 0x2000016e
PC : 0x20000170
PC : 0x20000172
PC : 0x2000016e
PC : 0x20000170
PC : 0x20000172
PC : 0x2000016e
PC : 0x20000170
PC : 0x20000172
.
.
.
.
.
</code></pre></td><td><pre tabindex=0><code>20000118 &lt;main&gt;:
20000118:	b672      	cpsid	i
2000011a:	4817      	ldr	r0, [pc, #92]	; (20000178 &lt;delay_loop+0xa&gt;)
2000011c:	f04f 0110 	mov.w	r1, #16
20000120:	6802      	ldr	r2, [r0, #0]
20000122:	ea42 0201 	orr.w	r2, r2, r1
20000126:	6002      	str	r2, [r0, #0]
20000128:	4814      	ldr	r0, [pc, #80]	; (2000017c &lt;delay_loop+0xe&gt;)
2000012a:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
2000012e:	6001      	str	r1, [r0, #0]
20000130:	4813      	ldr	r0, [pc, #76]	; (20000180 &lt;delay_loop+0x12&gt;)
20000132:	f44f 5100 	mov.w	r1, #8192	; 0x2000
20000136:	6001      	str	r1, [r0, #0]
20000138:	4812      	ldr	r0, [pc, #72]	; (20000184 &lt;delay_loop+0x16&gt;)
2000013a:	f06f 417f 	mvn.w	r1, #4278190080	; 0xff000000
2000013e:	6001      	str	r1, [r0, #0]
20000140:	4811      	ldr	r0, [pc, #68]	; (20000188 &lt;delay_loop+0x1a&gt;)
20000142:	f04f 0105 	mov.w	r1, #5
20000146:	6001      	str	r1, [r0, #0]
20000148:	480d      	ldr	r0, [pc, #52]	; (20000180 &lt;delay_loop+0x12&gt;)
2000014a:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
2000014e:	f44f 5200 	mov.w	r2, #8192	; 0x2000

20000152 &lt;blink_loop&gt;:
20000152:	6001      	str	r1, [r0, #0]
20000154:	f000 f804 	bl	20000160 &lt;delay&gt;
20000158:	6002      	str	r2, [r0, #0]
2000015a:	f000 f801 	bl	20000160 &lt;delay&gt;
2000015e:	e7f8      	b.n	20000152 &lt;blink_loop&gt;

20000160 &lt;delay&gt;:
20000160:	b407      	push	{r0, r1, r2}
20000162:	480a      	ldr	r0, [pc, #40]	; (2000018c &lt;delay_loop+0x1e&gt;)
20000164:	f44f 31b0 	mov.w	r1, #90112	; 0x16000
20000168:	6001      	str	r1, [r0, #0]
2000016a:	f04f 020a 	mov.w	r2, #10

2000016e &lt;delay_loop&gt;:
2000016e:	6801      	ldr	r1, [r0, #0]
20000170:	4291      	cmp	r1, r2
20000172:	dafc      	bge.n	2000016e &lt;delay_loop&gt;
20000174:	bc07      	pop	{r0, r1, r2}
20000176:	4770      	bx	lr
20000178:	40021018 	andmi	r1, r2, r8, lsl r0
2000017c:	40011004 	andmi	r1, r1, r4
20000180:	40011010 	andmi	r1, r1, r0, lsl r0
20000184:	e000e014 	and	lr, r0, r4, lsl r0
20000188:	e000e010 	and	lr, r0, r0, lsl r0
2000018c:	e000e018 	and	lr, r0, r8, lsl r0
</code></pre></td></tr></table><p>As you can see the control flow via single stepping matches the disassembly output.</p><p>Key things to take care of when executing from SRAM are:</p><ul><li>Reset_Handler address must have the 1st bit set to enable thumb-mode.</li><li>The VTOR must be relocated to SRAM before resuming the core.</li><li>The MSP must also be set along with the PC.</li></ul><h2 id=breakpoints>BreakPoints!<a hidden class=anchor aria-hidden=true href=#breakpoints>#</a></h2><p>Now, lets wrap the debug section up by briefly talking about breakpoint.</p><p>ARMv7-M supports 2 types of breakpoints</p><ul><li>Hard Breakpoints</li><li>Soft Breakpoints.</li></ul><p><em>-Depending on the functionality of FPB unit implemented by the SoC vendor, either all or parts of the following are true.-</em></p><p>Hard Breakpoints are made possible by the FPB (Flash Patching and BreakPoint Unit).</p><p>It consists of registers which which act as comparators, You set them up with the value of PC where you want the breakpoint to be and as soon as the control reaches to the PC value, the PC is remapped to the address present in FP_REMAP register of FPB unit <strong>or</strong> to a <em>bkpt</em> instruction, which will eventually trigger a DebugMon exception.</p><p>There are about 2-8 comparators available in FPB, the actual value is IMPLEMENTATION DEFINED.</p><p>Soft Breakpoints are make possible by the <em>bkpt</em> instuction of ARMv7-M.</p><p>Depeding on how things are set up, as soon as control reaches this instruction, the CPU enters debug state by entering the DebugMon exeption.</p><h2 id=why-dont-you-just-flash-them>Why don&rsquo;t you just FLASH them?<a hidden class=anchor aria-hidden=true href=#why-dont-you-just-flash-them>#</a></h2><p>This is the final part of this article and the only remaining quest of our journey.</p><p>We have learned about SWD, How debugging works, how to make, run and debug our own firmware via our own debugger.</p><p>The only thing that remains is the question of how does FLASH programming works?</p><p>This is where things get messy.</p><p>Unlike the other stuff that we have mentioned above, FLASH programming in ARM ecosystem is completely non-standardised.</p><p>It is upto the job of the SoC vendor to define the specifics of how their system enables this process to happen.</p><p>This is why we see every SoC vendor provide their own tools and debuggers/programmers.</p><p>ST has ST-link, NXP has LPC-link/MCU-link, TI, SiLabs, Atmel everyone has their own way.</p><p>This is good as it provides flexibility for SoC vendors, Its also bad for us because making a universal programmer is now a very difficult job.</p><p>There are companies out there that actualy spend time and money over this and have made a hugely succesful business out of it. (SEGGER)</p><p>But still some of the ways this process happens are listed below:</p><ol><li>Manually Program the FLASH using MEM-AP to access whatever FLASH programming peripheral is implemented in the SoC.</li><li>Upload a FLASHLOADER and binary to SRAM and use it to access the FLASH programming peripheral and FLASH the binary.</li><li>Use any helper functions implemented inside the ROM to program the flash.</li></ol><p>Out of these, 1st method is the slowest as it is dependent on the speed at which you can transact over SWD.</p><p>2nd method is the most used followed by 3rd method in some cases.</p><p>We will use the 2nd method.</p><p>To do this, We will program a special binary into the SRAM called the FLASHLOADER.</p><p>The job of the FLASHLOADER is to run on the target core and program its FLASH by accessing the internal memory mapped peripheral responsible to do so.</p><p>This FLASHLOADER can run at the speed that core can run natively thus is way faster that doing it manually via individual SWD MEM-AP transactions.</p><p>The program to upload is also put inside the SRAM, broken into smaller blocks depending on the size of the binary to FLASH.</p><p>The FLASHLOADER can then flash the part in SRAM, and then signal the debugger using any number of mechanisms.</p><p>The debugger can then upload the next block to program and then re-runs the FLASHLOADER, this happens until the whole binary is FLASHED.</p><p>On our TARGET (STM32F103) the FLASH programming is taken care of by the FPEC. (Flash Programming and Erase Controller)</p><p>The FLASHLOADER that I have used is shown below.</p><p>It uses R0,R1,R2 and R3 to pass the start address of flash,sram, size of block, to mass erase or not.</p><pre tabindex=0><code>.syntax unified

.global flashloader

.thumb

.align 2

#Keys for unlocking access to FPEC(Flash Program and Erase Controller) on STM32F10XXX series.
.equ FLASH_KEY1,	0x45670123
.equ FLASH_KEY2,	0xCDEF89AB

#FPEC registers
.equ FLASH_ACR,		0x40022000
.equ FLASH_KEYR,	0x40022004
.equ FLASH_OPTKEYR,	0x40022008
.equ FLASH_SR,		0x4002200C
.equ FLASH_CR,		0x40022010
.equ FLASH_AR,		0x40022014
.equ FLASH_OBR,		0x4002201C
.equ FLASH_WRPR,	0x40022020

.equ DEBUG_DCRDR,	0xE000EDF8
.equ MAGIC_WORD, 	0xD33DB33F

.section .text

.word 0x20004000
.word flashloader
.word NMI_Handler
.word HardFault_Handler

NMI_Handler:
	b NMI_Handler

HardFault_Handler:
	b HardFault_Handler

flashloader:
	#disable interrupts
	cpsid i

	push {r0-r4}

	#unlock FPEC registers by writing the unlock sequence
	ldr r0,=FLASH_KEYR
	ldr r1,=FLASH_KEY1
	ldr r2,=FLASH_KEY2
	str r1,[r0]
	str r2,[r0]

	#wait for flash to be free from pending ops before proceeding, useful on sudden reset of debugger.
	bl busy_check

	pop {r0-r4}

	#r0 contains the start address of flash write operation
	#r1 contains the start address of data in SRAM
	#r2 contains the number of bytes to write, i.e the size of data
	#r3 contains whether the request is for only mass erase or for program.

	#check if mass erase only set.
	mov r8,0x1
	cmp r8,r3
	beq mass_erase

	#prepare r8 to host SRAM base + SRAM data
	mov r8,r1
	add r8,r2

.align 2
program_loop:
	#set PG bit in flash control register.
	ldr r5,=FLASH_CR
	mov r6,0x1
	strh r6,[r5]

	#load the data in SRAM at r1 into r5
	ldr r5,[r1]

	#store lower half-word at the FLASH address given by r0
	strh r5,[r0]

	bl busy_check

	#add 2 to the FLASH address.
	add r0,0x2

	#set PG bit in flash control register.
	ldr r5,=FLASH_CR
	mov r6,0x1
	strh r6,[r5]

	#shift upper half to lower
	ldr r5,[r1]
	lsr r5,r5,16

	#store the upper half into the updated FLASH address
	strh r5,[r0]

	bl busy_check

	#add 2 to the FLASH address.
	add r0,0x2
	#mov to the next word in SRAM
	add r1,0x4

	cmp r8,r1

	bne program_loop

	#signal to the debugger that we are done.
	ldr r0,=DEBUG_DCRDR
	ldr r1,=MAGIC_WORD
	str r1,[r0]

	b .

.align 2
mass_erase:
	#start the erase operation.
	ldr r0,=FLASH_CR
	mov r1,0x4
	str r1,[r0]
	ldr r1,[r0]
	orr r1,0x40
	str r1,[r0]

	#wait for mass erase to complete
	bl busy_check

	#signal to the debugger that we are done.
	ldr r0,=DEBUG_DCRDR
	ldr r1,=MAGIC_WORD
	str r1,[r0]

	b .

.align 2
busy_check:
	push {r0-r4}

.align 2
bc_loop:
	ldr r0,=FLASH_SR
	ldr r1,[r0]
	mov r2,0x1
	and r1,r2
	beq bc_loop

	pop {r0-r4}

	bx lr
</code></pre><h2 id=the-gist-of-it-all>The Gist of it all.<a hidden class=anchor aria-hidden=true href=#the-gist-of-it-all>#</a></h2><p>If you have stayed this far then congratulations!</p><p>You now are familiar with:</p><ul><li>ARM SWD PHY layer and protocol.</li><li>How debugging works on ARMv7-M.</li><li>Different methods used to Program FLASH.</li></ul><p>The last thing to explain is how this works in general tools and debuggers for example ST-link, MCU-link, J-link etc..</p><p>All of these debuggers mentioned above do the same things explained in this artitle.</p><p>The are just given the commands by your IDE running a GDB session.</p><p>All these manufacturers have their own client application running on a HOST computer.</p><p>This application communicates over USB/Ethernet to the debugger.</p><p>This application also sets up a GDB server running the GDB Remote Serial Protocol.</p><p>Our IDEs GDB session then connects to this server as a remote target to actually sent commands for debugging which are then forwareded over USB/Ethernet to the actual physical debugger.</p><p>Thats it for today folks!</p><p>I hope you learned someting out of this. :)</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p><a href=https://developer.arm.com/documentation/ihi0031/a/Overview-of-the-ARM-Debug-Interface-and-its-components>ARM Debug Interface v5 Architecture Specification</a></p><p><a href=https://developer.arm.com/documentation/ddi0314/latest/>CoreSign Components TRM</a></p><p><a href=https://developer.arm.com/documentation/ddi0403/latest/>ARMv7-M Architecture Reference Manual</a></p><p>ARM Cortex-M3 TRM / ARM Cortex-M4 TRM / ARM Cortex-M7 TRM</p><p><a href="https://www.google.com/search?q=nxp+application+note+AN11553&amp;oq=nxp+application+note+AN11553&amp;aqs=chrome..69i57j33i10i160.3334j0j4&amp;sourceid=chrome&amp;ie=UTF-8">NXP Application Note AN11553</a></p><p><a href=https://www.silabs.com/documents/public/application-notes/an0062.pdf>SiLabs Application Note AN0062</a></p><p><a href=https://www.st.com/resource/en/reference_manual/rm0008-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf>STM32F10XX Reference Manual</a></p><p><a href=https://www.st.com/resource/en/programming_manual/pm0075-stm32f10xxx-flash-memory-microcontrollers-stmicroelectronics.pdf>STM32 PM0076 Programming Manual</a></p></div><footer class=post-footer><nav class=paginav><a class=next href=http://qcentlabs.com/posts/ml_on_mcu/><span class=title>Next Page »</span><br><span>Machine Learning on Microcontrollers.</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Making my own Programmer/Debugger using ARM SWD. on twitter" href="https://twitter.com/intent/tweet/?text=Making%20my%20own%20Programmer%2fDebugger%20using%20ARM%20SWD.&amp;url=http%3a%2f%2fqcentlabs.com%2fposts%2fswd_banger%2f&amp;hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Making my own Programmer/Debugger using ARM SWD. on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fqcentlabs.com%2fposts%2fswd_banger%2f&amp;title=Making%20my%20own%20Programmer%2fDebugger%20using%20ARM%20SWD.&amp;summary=Making%20my%20own%20Programmer%2fDebugger%20using%20ARM%20SWD.&amp;source=http%3a%2f%2fqcentlabs.com%2fposts%2fswd_banger%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Making my own Programmer/Debugger using ARM SWD. on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fqcentlabs.com%2fposts%2fswd_banger%2f&title=Making%20my%20own%20Programmer%2fDebugger%20using%20ARM%20SWD."><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Making my own Programmer/Debugger using ARM SWD. on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fqcentlabs.com%2fposts%2fswd_banger%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Making my own Programmer/Debugger using ARM SWD. on whatsapp" href="https://api.whatsapp.com/send?text=Making%20my%20own%20Programmer%2fDebugger%20using%20ARM%20SWD.%20-%20http%3a%2f%2fqcentlabs.com%2fposts%2fswd_banger%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Making my own Programmer/Debugger using ARM SWD. on telegram" href="https://telegram.me/share/url?text=Making%20my%20own%20Programmer%2fDebugger%20using%20ARM%20SWD.&amp;url=http%3a%2f%2fqcentlabs.com%2fposts%2fswd_banger%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://qcentlabs.com/>qcentlabs</a></span>
<span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>