<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The Core Wars, ARM Cortex M0+ vs M3 vs M4 vs M7 | qcentlabs</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-PWDYJX7Y6B"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PWDYJX7Y6B")</script><meta name=keywords content><meta name=description content="Microcontrollers are powerful tiny computers, and it&rsquo;s no surprise that we love them here at qcentlabs.
But what sets different microcontrollers apart?
Well, Microcontrollers essentially are made up of a CPU core, some memory and specialized peripherals. Almost all modern microcontrollers feature a RISC based core.
These core(s) are either made in house or are licensed from a separate core IP vendor.
Example of popular in house developed architecture and core include AVR,PIC,MSP430 etc."><meta name=author content="magalsh64"><link rel=canonical href=http://qcentlabs.com/posts/core-wars/><meta name=google-site-verification content="G-PWDYJX7Y6B"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://qcentlabs.com/logo.png><link rel=icon type=image/png sizes=16x16 href=http://qcentlabs.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://qcentlabs.com/favicon-32x32.png><link rel=apple-touch-icon href=http://qcentlabs.com/logo.png><link rel=mask-icon href=http://qcentlabs.com/logo.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.119.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="The Core Wars, ARM Cortex M0+ vs M3 vs M4 vs M7"><meta property="og:description" content="Microcontrollers are powerful tiny computers, and it&rsquo;s no surprise that we love them here at qcentlabs.
But what sets different microcontrollers apart?
Well, Microcontrollers essentially are made up of a CPU core, some memory and specialized peripherals. Almost all modern microcontrollers feature a RISC based core.
These core(s) are either made in house or are licensed from a separate core IP vendor.
Example of popular in house developed architecture and core include AVR,PIC,MSP430 etc."><meta property="og:type" content="article"><meta property="og:url" content="http://qcentlabs.com/posts/core-wars/"><meta property="og:image" content="http://qcentlabs.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-16T11:51:12+05:30"><meta property="article:modified_time" content="2023-10-16T11:51:12+05:30"><meta property="og:site_name" content="qcentlabs"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://qcentlabs.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="The Core Wars, ARM Cortex M0+ vs M3 vs M4 vs M7"><meta name=twitter:description content="Microcontrollers are powerful tiny computers, and it&rsquo;s no surprise that we love them here at qcentlabs.
But what sets different microcontrollers apart?
Well, Microcontrollers essentially are made up of a CPU core, some memory and specialized peripherals. Almost all modern microcontrollers feature a RISC based core.
These core(s) are either made in house or are licensed from a separate core IP vendor.
Example of popular in house developed architecture and core include AVR,PIC,MSP430 etc."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://qcentlabs.com/posts/"},{"@type":"ListItem","position":2,"name":"The Core Wars, ARM Cortex M0+ vs M3 vs M4 vs M7","item":"http://qcentlabs.com/posts/core-wars/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The Core Wars, ARM Cortex M0+ vs M3 vs M4 vs M7","name":"The Core Wars, ARM Cortex M0\u002b vs M3 vs M4 vs M7","description":"Microcontrollers are powerful tiny computers, and it\u0026rsquo;s no surprise that we love them here at qcentlabs.\nBut what sets different microcontrollers apart?\nWell, Microcontrollers essentially are made up of a CPU core, some memory and specialized peripherals. Almost all modern microcontrollers feature a RISC based core.\nThese core(s) are either made in house or are licensed from a separate core IP vendor.\nExample of popular in house developed architecture and core include AVR,PIC,MSP430 etc.","keywords":[],"articleBody":"Microcontrollers are powerful tiny computers, and it’s no surprise that we love them here at qcentlabs.\nBut what sets different microcontrollers apart?\nWell, Microcontrollers essentially are made up of a CPU core, some memory and specialized peripherals. Almost all modern microcontrollers feature a RISC based core.\nThese core(s) are either made in house or are licensed from a separate core IP vendor.\nExample of popular in house developed architecture and core include AVR,PIC,MSP430 etc..\nExamples of popular licensed architecture and core include ARM Cortex-M, Xtensa etc..\nFor a long time, the MCU space has been segmented into 3 parts, 8bit MCUs, 16bit MCUs and 32bit MCUs.\nAlthough 8 and 16 bit MCUs have a huge legacy in the industry, the 32bit MCUs are slowly replacing them even at somewhat cost sensitive applications.\nARM Cortex-M offers some of the most popular cores in the 32bit microcontroller space.\nToday we will have a look into what is the difference between different cores in the ARM Cortex-M series, so that you can be sure that you have chosen the right MCU for your application.\nThe ARM Cortex-M ARM offers architectural/processor core IPs under the Cortex brand, seprated into 3 broad segments, Cortex-A,Cortex-M and Cortex-R.\nARM Cortex-M refers to a series of 32bit in-order core IPs developed by ARM limited for the general industrial/consumer microcontroller market targeting low power, low cost, deterministic embedded applications.\nUnder ARM’s Cortex-M series, different cores were developed to target different segments of the market.\nAs microcontrollers can be found in things as simple as light switches or toys, to things as complicated as medical ventilators, different cores were designed to cater specific need in terms of compute capabilty, power draw and cost.\nUnder the Cortex-M umbrella, ARM launched its first core, Cortex-M3 in october of 2004.\nThe Cortex-M3 was meant to be the mainstream core in the Cortex-M lineup.\nIt was based on the ARMv7-M architecture and ran the Thumb2 ISA, had a 3 stage integer pipeline, instructions for hardware division, single-cycle multiply capability and consumed a measly 11uW/Mhz.\nWhy was so special in this?\nWell in the early 2000s, the microcontroller industry was mainly dominated by 8bit and 16bit CPU cores, these include the PIC family from Microchip and the AVR family from Atmel.\nThe thing with these 8 bit PICs and AVRs was that they did not have native division instructions! some even did not have multiply instructions! Thus division and multiplication operations had to be done in software which was very slow for compute intensive applications!\nAVRs and PICs later (AVR4+ \u0026 PIC18+) did add support for hardware multiply but it took more than 1 cycle and in most cases only produced a 16 bit result.\nCompared to these 8bit counterparts, the Cortex-M3 was capable of hardware division in under 2-12(worst case) cycles and had single cycle 32bit * 32bit multiply with 32bit result capability, which destroyed the 8bit cores in compute.\nBut this was not all, no-no sir, ARM entered the market seeking utter destruction.\nCortex-M3 was based on a Harvard Bus Architecture, with 4 AHB-Lite busses called ICode bus,DCode bus, System bus and PPB bus.\nAlthough there were seperate busses for instruction and data fetch (Harvard Architecture), these were combined into a single linear addressable memory region via a bus-matrix unifying code and data space from programmers point of view (Von neumann Architecture).\nThe ICode bus was read-only and fetched 16bit aligned instructions from code space. (0x00000000 - 0x1FFFFFFF)\nThe DCode bus was R/W capable and mainly fetched 32bit literals from code space. (0x00000000 - 0x1FFFFFFF)\nSpliting the bus into 2 parts could allow the core to fetch both instruction and literals in parellel improving performance, although this was highly depended on how the systems bus design was implemented by the SoC vendor.\nSystem bus could fetch code and data and also allowed debug access into the memory space. (0x20000000 - 0xDFFFFFFF and 0xE0100000 - 0xFFFFFFFF)\nThere was an internal PPB (Private Peripheral Bus) bus (0xE0000000 - 0xE003FFFF) and an external PPB bus (0xE0040000 - 0xE00FFFFF), these were used to access cores internal memory mapped components and external optional components that could be implemented by the SoC vendor.\nCortex-M3 had NVIC(Nested Vectored Interrupt Controller) for low latency interrupt handling, providing:\nSupport for upto 240 interrupts with 256 priority levels of which first 16 interrupts are core CPU exceptions. Support for interrupt preemption based on priority. Support for tail-chaining and automatic state saving and restoring. Support for relocation of vector table using a dedicated register. It also featured an optional MPU(Memory Protection Unit) that enabled upto 8 memory regions to be defined that had specific access permissions associated with them.\nAlso ARMv7-M being a load-store architecture, support was included for bit-banding which allowed toggling of individual bits in certain sections of memory via writes to a single 32bit address which reduced code footprint and improved performance.\nCortex-M3 also had inbuild support for 2 low power modes termed Sleep and Deep Sleep and additional support for an optional WIC(Wake-up Interrupt Controller) with SRPG(State Retention and Power Gating) so that the whole core and NVIC can be power and clock gated in deep sleep.\nThe core had great support for fault handling with dedicated exceptions and special pourpose registers that immensely helped with debugging.\nThe Cortex-M3 also had an inbuilt 24bit timer that could be driven by the CPU clock called SysTick.\nARM provived an ecosystem of IPs and options along with the base core IP that helped designers expand the capabilities of the core, this included support for debugging and trace components such as DAP, ETM, ITM, ARMs PrimeCell IPs for bus matirx, GPIO, and various other peripherals.\nAll in all, this was a terrific package that would become highly successful in the industry.\nAround 2009, ARM introduced an even more optimized design intended for extremely small silicon area and very low power to be used in highly cost sensitive applications that only required little compute i.e a direct competition to still popular 8bit MCUs.\nThis was the Cortex-M0, it was based on the ARMv6-M architecture which was a step back from the Cortex-M3’s ARMv7-M.\nAs ARMv6-M only had support for 16bit Thumb1 instructions and very limited 32bit instructions for a total of 56 instructions, it was very efficient in terms of code space and power.\nIt had the same 3 stage integer pipeline as Cortex-M3.\nInterrupts were cut down from 240 to just 32 (of which only 2 were core CPU exceptions).\nHardware support for multiply instruction was included but divison instruction was removed.\nMPU support was removed and so was support for dedicated fault exceptions and special registers.\nVector table was fixed at 0x00000000 with no support for VTOR.\nThis core became popular for low pin count low cost MCUs and was also used as a secondry core coupled with a more powerful core later on in its life, altough it would be later superseded with a newer version of itself.\nIn 2010 ARM introduced the Cortex-M4, which essentialy was a juiced up Cortex-M3.\nCortex-M4 was the first IP in the Cortex-M lineup that used ARMv7E-M and had inbuilt support for DSP/SIMD instructions.\nCortex-M4 was also the first to feature an optional IEEE 754 complient Single Precision FPU (FPv4).\nBefore Cortex-M4, the industry generally used a specialised DSP chip along with a seperate MCU for general DSP applications, with Cortex-M4, ARMs goal was to combine both a DSP and a MCU into a single chip solution by adding special SIMD instructions.\nCortex-M4 also had improved NVIC with support for Lazy Stacking for FPU, which essentially allowed the FPU registers states to not be stored in the exception handlers stack frame until the exception handler executed any FPU instruction, only after executing any FPU instruction did the state saving occured, this improved interrupt latency as in most cases exceptions did not utilize the FPU.\nThis feature was in complient with Procedure Call Standard for ARM Architecture.\nCortex-M4 became the go to choice for medium to high performance applications in respect to the MCU world.\nAfter Cortex-M4, in 2012 ARM released a revision to Cortex-M0 called ARM Cortex-M0+.\nCortex-M0+ was designed to be even more power effecient than Cortex-M0 while also adding back some features.\nIt featured only a 2 stage integer pipeline to which reduced power consumption by 30% compared to M0.\nIt was based on pure von-neumann architecture and only had a single AHB-Lite bus, although this shrank die size due to only a single bus being routed, it also meant that code and data access were now combined on a single bus and could not be done in parellel, this led to latency and jitter for some applications that required precise timings.\nTo deal with this, ARM introduced a seperate single-cycle access port for peripherals that required precise timing controls.\nIt added back optional MPU support that was removed from M0.\nIt also brought back optional support for VTOR.\nCortex-M0+ is currently the lowest power, most efficient and smallest sized Cortex-M core in ARMs lineup, it is used by majority of low end MCUs and is currently the most potent competitor to still standing 8bit and 16bit MCUs in the market.\nIn about 2010-2012s, the smartphone revolution was taking place and everybody was becoming accustomed to fluid UIs offered by smartphone apps, demand was rising in the embedded space for applications that required more and more powerful MCUs that could drive big displays and offer similar experience to a modern smartphones UI while still being powerful and deterministic enough for real time applications.\nTo address this, ARM introduced it’s most powerful core based on ARMv7E-M at that time, the ARM Cortex-M7 in 2014.\nThe Cortex-M7 was build from ground up for performance.\nIt featured an in-order superscaler 6 stage integer pipeline with the ability to dual issue many of the Thumb2 instructions and support for BTAC(Branch Target Address Cache) for reducing branch penalties in loops.\nIt featured optional support for upto 64KB of Instruction and Data Cache with ECC.\nIt featured optional support for upto 16MB of ITCM and DTCM with ECC. TCMs or Tightly Coupled Memory allows 0-latency single cycle dual port access, with clocks coupled with the ARMs core clock and bypasses the system cache i.e super fast deterministic memory closely coupled to core operating at the cores frequency.\nIt switched from ARMAs AHB-Lite bus featured in previous Cortex-M cores to the newer AXI bus which heavily improved systems memory throughput.\nIt bought support for the first double precision FPU in ARMs Cortex-M lineup (FPv5).\nIt had optional MPU support with upto 16 different mappable memory regions.\nIt also bought support for ARMs Dual Core Lock-Step technology for systems that required utmost reliability.\nIt featured improved DSP/SIMD support.\nAll-in-All as of september of 2023, The ARMs Cortex-M7 is the highest performing core that is currently implemented, feild tested and is available for purchase in bulk in products by major silicon vendors.\nParellel to the launch of Cortex-M7 in 2014, another trend was on the rise in the industry, the trend of cheap and small devices to be able to connect to the internet and provide networked and smart connected solutions for day to day appliances. This is what the industry named Internet of Things.\nThe ESP8266 launched in 2014 and exploded in the hobbyist community, The possibily of a MCU costing only a few dollars having the capability to connect to the internet with WiFi radio and a TCP/IP stack being cheaply available further fueled the IoT bandwagon.\nThis gave rise to another challenge in the industry, the challenge to make millions of IoT devices to be possibly deployed in the future secure.\nIf every small day to day device had the possibility to become smart and be connected to internet, so did the possibility for a malicious group to use this as an advantage to penetrate millions of devices for malicious intent.\nThus, the next generation of cores were to be designed with hardened security in mind.\nThis came true with the introduction of ARMv8-M Architecture.\nARMv8-M Architecture came split into 2 profiles, ARMv8-M Baseline and ARMv8-M Mainline.\nARMv8-M Baseline profile was meant for low gate count, super low power designs and was the successor to ARMv6-M.\nARMv8-M Baseline in addition to all features present in ARMv6-M, had\nadded dedicated support for hardware divison added support for addional 32bit instructions added support for Exclusion Monitor (already present in ARMv7-M) and Load Acquire Store Release semantics. added support for improved MPU based on PMSAv8. added support for SAU (Security Attribution Unit) and IDAU (Implementation Definined Attribution Unit) added support for security enhancements. (TrustZone and Stack Limit/Stack Sealing) ARMv8-M Mainline profile was meant for mainstream and high performance applications and was successor to ARMv7-M.\nARMv8-M Mainline included all features present in ARMv8-M Baseline and ARMv7-M.\nARMv8-M had special focus on inclusion of security enhancements for IoT designs, the most prominent of it was ARM’s TrustZone technology borrowed from the companies Cortex-A lineup a cut down version of which was now available for Cortex-M.\nThe first cores that ARM launched featuring ARMv8-M were ARM Cortex-M23 and Cortex-M33 in the year 2016.\nARMs TrustZone allowed 2 comepletely independent sets of firmware to run on the core, one in Secure state and the other in Non-Secure state.\nThe firmware in the secure state could have complete access to the whole systems resources and act as a hypervisor.\nThe firmware in the non-secure state could be limited to only a subset of resources available to the system.\nThis allowed the possibility of IoT devices having compromised firmware running in the non-secure state, to be reflashed OTA via the hypervisor running in the secure state. (just an example)\nTrustZone also allowed the possibility for specific parts of the system (firmware for radios) to be only run in the secure state and the non-secure state did not have direct access to these resources, so damage caused by a compromised non-secure could be contained.\nAltough it was possible to build secure applications using ARMv7-M as it featured privilaged and non-privilaged states, TrustZone simplified the development process and offered a better implementation for security.\nThe Cortex-M23 was to be the next generation replacement for Cortex-M0+.\nIt offered almost the same features as the Cortex-M0+, 2 stage in-order integer pipeline, but with added benifits of ARMv8-M Baseline.\nSimilarly, the Cortex-M33 was to be the next generation replacement for Cortex-M3 but had features more in-line to Cortex-M4.\nIt too offered the same general capabilities as the Cortex-M4 with the added features and security extentions of ARMv8-M Mainline.\nThe ARMv8-M did offer compute improvements with a more efficient core design and M23 and M33 were therefore faster than M0+ and M4.\nAnother major change in ARMv8-M was the ability for SoC implementor to include Custom instructions via CDE.\nThe next big change in the industry came due to rise of another technology, AI and Machine Learning.\nBy the late 2010s, AI and ML revolution was on the rise and there was heavy demand in the industry to have the capability to run ML models on the edge.\nARM responded to this with the introduction of ARMv8.1-M with inclusion of Helium (M-profile Vector Extentions).\nHelium added support for improved and wider vector instructions (than ARMv7E-Ms) that gave the core a major uplift(upto 4x) in throughput for AI/ML applications.\nARMv8.1-M also bought new architectural features related to security (PACBTI), reliability (RAS), performance monitoring (PMU) and debugging enhancements.\nARM launched Cortex-M55 in 2020 and Cortex-M85 in 2022 both of which were based on ARMv8.1-M.\nARM also launched its Ethos NPUs (u55 and u65) which could be integrated with M55 and M85 cores to get even more improved AI/ML throughput.\nNow that you know what each of our condentors are and how they differ from each other lets benchmark them to see how much synthetic difference in performance do they have.\nLet the battle begin. Unfortunately, not all of the cores mentioned above are actually available in the market as of today.\nThere are large number of products in the market based on the older ARMv6-M and ARMv7-M lineup (Cortex-M0+,M3,M4,M7).\nBut only few manufacturers have products that feature the newer ARMv8-M/ARMv8.1-M lineup, the most famous of which currently is the Cortex-M33 followed by M23.\nI could not find any Cortex-M55 based MCU, and Renesas only just released (late september of 2023) the RA8M1 series featuring Cortex-M85.\nI have in hand access to products based on M0+,M3,M4,M7. (I also have a SoC with M33 but that is bare sample chip w/o breakout board)\nThus we will be benchmarking these M0+,M3,M4 and M7 based products which are still highly popular and currently in use in the industry.\nThe performance of each core is highly dependent on the overall system implementation by the SoC vendor and thus these tests are only performed to get a general idea.\nThe M0+ will be from a RP2040.\nThe M3 will be from a STM32F103C8.\nThe M4 will be from a STM32F410RB.\nThe M7 will be from a MIMXRT1166DVM6A.\nFirst round will focus integer performance.\nAlthough IPC is a great measure to distinguish core-to-core performance difference, in real world scenarios, the higher performing cores are manufactured on better silicon nodes and have larger pipelines thus natively yeild higher clocks, hence raw throughput on available platforms featuring each core is also provided, although this is an aproximation and the actual value can be higher or lower depending on the test implementation, here 1024 instructions were executed within a loop that was unrolled 32 times, the cycles taken were then used to extrapolate for MIPS (Million Instructions Per Second).\nThe second round will be floating point performance.\nPlatforms that feature a FPU will utilize it, others will emulate the operations in software, newlib-nano was used as the glibc (other libraries might perform better but do not come standard with the toolchain).\nThe third round will on memory bandwitdh, absolute maximum throughput in read,write will be tested, if the platform offers different types of internal/external memories, all will be tested. The absolute maximum throughput only gives the maximum theoretical achievable bandwith on sythentic workloads, most real world use cases will yeild much lower results.\nWe can extract the following information from all this data:\nCortex M7 provides upto 2x IPC in general use cases as compared to other cores as it can dual issue common instructions under certain conditions. Cortex M4/M3/M0+ have the same IPC in general add/sub/mul instructions. Cortex-M7 due to larger 6 stage pipeline has larger latencies for INT division and all FP instructions, to maximise performance instruction level parallelism must be exploited, GCC does a very bad job at this (even at -O3), so if you have a workload demanding high performance floating point arethmetic be prepared to manually optimise it in assembly. Cortex-M7 has very high memory bandwidth with zero latecy for TCM which scales linearly with CPU clock. Our Cortex-M7 contender (MIMXRT1166) performs worse on reads than in writes for some memories due to writes being pipelined and issues with NIC priority, OCRAM and SDRAM are optimised for multi-master access. FP compute on Cortex-M3 and M0+ is much slower due to no hardware support and software emulation, the real world performance can be greater than what is stated here depending on the implementation of software FPU functions. Wierdly, Cortex-M3 featured in this test was based on STM32F103XX platform and yeilds lower results in INT compute per CLK than M0+ due to incursion of multiple branch penelties in throughput test. ","wordCount":"3247","inLanguage":"en","datePublished":"2023-10-16T11:51:12+05:30","dateModified":"2023-10-16T11:51:12+05:30","author":{"@type":"Person","name":"magalsh64"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://qcentlabs.com/posts/core-wars/"},"publisher":{"@type":"Organization","name":"qcentlabs","logo":{"@type":"ImageObject","url":"http://qcentlabs.com/logo.png"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=http://qcentlabs.com/ accesskey=h title="qcentlabs (Alt + H)">qcentlabs</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=http://qcentlabs.com/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://qcentlabs.com/>Home</a>&nbsp;»&nbsp;<a href=http://qcentlabs.com/posts/>Posts</a></div><h1 class=post-title>The Core Wars, ARM Cortex M0+ vs M3 vs M4 vs M7</h1><div class=post-meta><span title='2023-10-16 11:51:12 +0530 IST'>October 16, 2023</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;magalsh64</div></header><div class=post-content><p>Microcontrollers are powerful tiny computers, and it&rsquo;s no surprise that we love them here at qcentlabs.</p><p>But what sets different microcontrollers apart?</p><p>Well, Microcontrollers essentially are made up of a CPU core, some memory and specialized peripherals.
Almost all <em>modern</em> microcontrollers feature a RISC based core.</p><p>These core(s) are either made in house or are licensed from a separate core IP vendor.</p><p>Example of popular in house developed architecture and core include AVR,PIC,MSP430 etc..</p><p>Examples of popular licensed architecture and core include ARM Cortex-M, Xtensa etc..</p><p>For a long time, the MCU space has been segmented into 3 parts, 8bit MCUs, 16bit MCUs and 32bit MCUs.</p><p>Although 8 and 16 bit MCUs have a huge legacy in the industry, the 32bit MCUs are slowly replacing them even at somewhat cost sensitive applications.</p><p>ARM Cortex-M offers some of the most popular cores in the 32bit microcontroller space.</p><p>Today we will have a look into what is the difference between different cores in the ARM Cortex-M series, so that you can be sure that you have chosen the right MCU for your application.</p><h2 id=the-arm-cortex-m>The ARM Cortex-M<a hidden class=anchor aria-hidden=true href=#the-arm-cortex-m>#</a></h2><p>ARM offers architectural/processor core IPs under the <em>Cortex</em> brand, seprated into 3 broad segments, Cortex-A,Cortex-M and Cortex-R.</p><p>ARM Cortex-M refers to a series of 32bit in-order core IPs developed by ARM limited for the general industrial/consumer microcontroller market targeting low power, low cost, deterministic embedded applications.</p><p>Under ARM&rsquo;s Cortex-M series, different cores were developed to target different segments of the market.</p><p>As microcontrollers can be found in things as simple as light switches or toys, to things as complicated as medical ventilators, different cores were designed to cater specific need in terms of compute capabilty, power draw and cost.</p><p>Under the Cortex-M umbrella, ARM launched its first core, <strong>Cortex-M3</strong> in october of 2004.</p><p>The Cortex-M3 was meant to be the mainstream core in the Cortex-M lineup.</p><p>It was based on the ARMv7-M architecture and ran the Thumb2 ISA, had a 3 stage integer pipeline, instructions for hardware division, single-cycle multiply capability and consumed a measly 11uW/Mhz.</p><p>Why was so special in this?</p><p>Well in the early 2000s, the microcontroller industry was mainly dominated by 8bit and 16bit CPU cores, these include the PIC family from Microchip and the AVR family from Atmel.</p><p>The thing with these 8 bit PICs and AVRs was that they did not have native division instructions! some even did not have multiply instructions! Thus division and multiplication operations had to be done in software which was very slow for compute intensive applications!</p><p>AVRs and PICs later (AVR4+ & PIC18+) did add support for hardware multiply but it took more than 1 cycle and in most cases only produced a 16 bit result.</p><p>Compared to these 8bit counterparts, the Cortex-M3 was capable of hardware division in under 2-12(worst case) cycles and had single cycle 32bit * 32bit multiply with 32bit result capability, which destroyed the 8bit cores in compute.</p><p>But this was not all, no-no sir, ARM entered the market seeking utter destruction.</p><p>Cortex-M3 was based on a <em>Harvard Bus Architecture</em>, with 4 AHB-Lite busses called ICode bus,DCode bus, System bus and PPB bus.</p><p>Although there were seperate busses for instruction and data fetch (Harvard Architecture), these were combined into a single linear addressable memory region via a bus-matrix unifying code and data space from programmers point of view (Von neumann Architecture).</p><p>The ICode bus was read-only and fetched 16bit aligned instructions from code space. (0x00000000 - 0x1FFFFFFF)</p><p>The DCode bus was R/W capable and mainly fetched 32bit literals from code space. (0x00000000 - 0x1FFFFFFF)</p><p>Spliting the bus into 2 parts could allow the core to fetch both instruction and literals in parellel improving performance, although this was highly depended on how the systems bus design was implemented by the SoC vendor.</p><p>System bus could fetch code and data and also allowed debug access into the memory space. (0x20000000 - 0xDFFFFFFF and 0xE0100000 - 0xFFFFFFFF)</p><p>There was an internal PPB (Private Peripheral Bus) bus (0xE0000000 - 0xE003FFFF) and an external PPB bus (0xE0040000 - 0xE00FFFFF), these were used to access cores internal memory mapped components and external optional components that could be implemented by the SoC vendor.</p><p>Cortex-M3 had NVIC(Nested Vectored Interrupt Controller) for low latency interrupt handling, providing:</p><ul><li>Support for upto 240 interrupts with 256 priority levels of which first 16 interrupts are core CPU exceptions.</li><li>Support for interrupt preemption based on priority.</li><li>Support for tail-chaining and automatic state saving and restoring.</li><li>Support for relocation of vector table using a dedicated register.</li></ul><p>It also featured an optional MPU(Memory Protection Unit) that enabled upto 8 memory regions to be defined that had specific access permissions associated with them.</p><p>Also ARMv7-M being a load-store architecture, support was included for bit-banding which allowed toggling of individual bits in certain sections of memory via writes to a single 32bit address which reduced code footprint and improved performance.</p><p>Cortex-M3 also had inbuild support for 2 low power modes termed Sleep and Deep Sleep and additional support for an optional WIC(Wake-up Interrupt Controller) with SRPG(State Retention and Power Gating) so that the whole core and NVIC can be power and clock gated in deep sleep.</p><p>The core had great support for fault handling with dedicated exceptions and special pourpose registers that immensely helped with debugging.</p><p>The Cortex-M3 also had an inbuilt 24bit timer that could be driven by the CPU clock called SysTick.</p><p>ARM provived an ecosystem of IPs and options along with the base core IP that helped designers expand the capabilities of the core, this included support for debugging and trace components such as DAP, ETM, ITM, ARMs PrimeCell IPs for bus matirx, GPIO, and various other peripherals.</p><p>All in all, this was a terrific package that would become highly successful in the industry.</p><p>Around 2009, ARM introduced an even more optimized design intended for extremely small silicon area and very low power to be used in highly cost sensitive applications that only required little compute i.e a direct competition to still popular 8bit MCUs.</p><p>This was the <strong>Cortex-M0</strong>, it was based on the ARMv6-M architecture which was a step back from the Cortex-M3&rsquo;s ARMv7-M.</p><p>As ARMv6-M only had support for 16bit Thumb1 instructions and very limited 32bit instructions for a total of 56 instructions, it was very efficient in terms of code space and power.</p><p>It had the same 3 stage integer pipeline as Cortex-M3.</p><p>Interrupts were cut down from 240 to just 32 (of which only 2 were core CPU exceptions).</p><p>Hardware support for multiply instruction was included but divison instruction was removed.</p><p>MPU support was removed and so was support for dedicated fault exceptions and special registers.</p><p>Vector table was fixed at 0x00000000 with no support for VTOR.</p><p>This core became popular for low pin count low cost MCUs and was also used as a secondry core coupled with a more powerful core later on in its life, altough it would be later superseded with a newer version of itself.</p><p>In 2010 ARM introduced the <strong>Cortex-M4</strong>, which essentialy was a juiced up Cortex-M3.</p><p>Cortex-M4 was the first IP in the Cortex-M lineup that used ARMv7E-M and had inbuilt support for DSP/SIMD instructions.</p><p>Cortex-M4 was also the first to feature an optional IEEE 754 complient Single Precision FPU (FPv4).</p><p>Before Cortex-M4, the industry generally used a specialised DSP chip along with a seperate MCU for general DSP applications, with Cortex-M4, ARMs goal was to combine both a DSP and a MCU into a single chip solution by adding special SIMD instructions.</p><p>Cortex-M4 also had improved NVIC with support for Lazy Stacking for FPU, which essentially allowed the FPU registers states to not be stored in the exception handlers stack frame until the exception handler executed any FPU instruction, only after executing any FPU instruction did the state saving occured, this improved interrupt latency as in most cases exceptions did not utilize the FPU.</p><p>This feature was in complient with <em>Procedure Call Standard for ARM Architecture.</em></p><p>Cortex-M4 became the go to choice for medium to high performance applications in respect to the MCU world.</p><p>After Cortex-M4, in 2012 ARM released a revision to Cortex-M0 called ARM <strong>Cortex-M0+</strong>.</p><p>Cortex-M0+ was designed to be even more power effecient than Cortex-M0 while also adding back some features.</p><p>It featured only a 2 stage integer pipeline to which reduced power consumption by 30% compared to M0.</p><p>It was based on pure von-neumann architecture and only had a single AHB-Lite bus, although this shrank die size due to only a single bus being routed, it also meant that code and data access were now combined on a single bus and could not be done in parellel, this led to latency and jitter for some applications that required precise timings.</p><p>To deal with this, ARM introduced a seperate single-cycle access port for peripherals that required precise timing controls.</p><p>It added back optional MPU support that was removed from M0.</p><p>It also brought back optional support for VTOR.</p><p>Cortex-M0+ is currently the lowest power, most efficient and smallest sized Cortex-M core in ARMs lineup, it is used by majority of low end MCUs and is currently the most potent competitor to still standing 8bit and 16bit MCUs in the market.</p><p>In about 2010-2012s, the smartphone revolution was taking place and everybody was becoming accustomed to fluid UIs offered by smartphone apps, demand was rising in the embedded space for applications that required more and more powerful MCUs that could drive big displays and offer similar experience to a modern smartphones UI while still being powerful and deterministic enough for real time applications.</p><p>To address this, ARM introduced it&rsquo;s most powerful core based on ARMv7E-M at that time, the <strong>ARM Cortex-M7</strong> in 2014.</p><p>The Cortex-M7 was build from ground up for performance.</p><p>It featured an in-order superscaler 6 stage integer pipeline with the ability to dual issue many of the Thumb2 instructions and support for BTAC(Branch Target Address Cache) for reducing branch penalties in loops.</p><p>It featured optional support for upto 64KB of Instruction and Data Cache with ECC.</p><p>It featured optional support for upto 16MB of ITCM and DTCM with ECC. TCMs or Tightly Coupled Memory allows 0-latency single cycle dual port access, with clocks coupled with the ARMs core clock and bypasses the system cache i.e super fast deterministic memory closely coupled to core operating at the cores frequency.</p><p>It switched from ARMAs AHB-Lite bus featured in previous Cortex-M cores to the newer AXI bus which heavily improved systems memory throughput.</p><p>It bought support for the first double precision FPU in ARMs Cortex-M lineup (FPv5).</p><p>It had optional MPU support with upto 16 different mappable memory regions.</p><p>It also bought support for ARMs Dual Core Lock-Step technology for systems that required utmost reliability.</p><p>It featured improved DSP/SIMD support.</p><p>All-in-All as of september of 2023, The ARMs Cortex-M7 is the highest performing core that is currently implemented, feild tested and is available for purchase in bulk in products by major silicon vendors.</p><p>Parellel to the launch of Cortex-M7 in 2014, another trend was on the rise in the industry, the trend of cheap and small devices to be able to connect to the internet and provide networked and smart connected solutions for day to day appliances. This is what the industry named Internet of Things.</p><p>The ESP8266 launched in 2014 and exploded in the hobbyist community, The possibily of a MCU costing only a few dollars having the capability to connect to the internet with WiFi radio and a TCP/IP stack being cheaply available further fueled the IoT bandwagon.</p><p>This gave rise to another challenge in the industry, the challenge to make millions of IoT devices to be possibly deployed in the future <em>secure</em>.</p><p>If every small day to day device had the possibility to become smart and be connected to internet, so did the possibility for a malicious group to use this as an advantage to penetrate millions of devices for malicious intent.</p><p>Thus, the next generation of cores were to be designed with hardened security in mind.</p><p>This came true with the introduction of ARMv8-M Architecture.</p><p>ARMv8-M Architecture came split into 2 profiles, ARMv8-M Baseline and ARMv8-M Mainline.</p><p>ARMv8-M Baseline profile was meant for low gate count, super low power designs and was the successor to ARMv6-M.</p><p>ARMv8-M Baseline in addition to all features present in ARMv6-M, had</p><ul><li>added dedicated support for hardware divison</li><li>added support for addional 32bit instructions</li><li>added support for Exclusion Monitor (already present in ARMv7-M) and Load Acquire Store Release semantics.</li><li>added support for improved MPU based on PMSAv8.</li><li>added support for SAU (Security Attribution Unit) and IDAU (Implementation Definined Attribution Unit)</li><li>added support for security enhancements. (TrustZone and Stack Limit/Stack Sealing)</li></ul><p>ARMv8-M Mainline profile was meant for mainstream and high performance applications and was successor to ARMv7-M.</p><p>ARMv8-M Mainline included all features present in ARMv8-M Baseline and ARMv7-M.</p><p>ARMv8-M had special focus on inclusion of security enhancements for IoT designs, the most prominent of it was ARM&rsquo;s TrustZone technology borrowed from the companies Cortex-A lineup a cut down version of which was now available for Cortex-M.</p><p>The first cores that ARM launched featuring ARMv8-M were ARM <strong>Cortex-M23</strong> and <strong>Cortex-M33</strong> in the year 2016.</p><p>ARMs TrustZone allowed 2 comepletely independent sets of firmware to run on the core, one in Secure state and the other in Non-Secure state.</p><p>The firmware in the secure state could have complete access to the whole systems resources and act as a hypervisor.</p><p>The firmware in the non-secure state could be limited to only a subset of resources available to the system.</p><p>This allowed the possibility of IoT devices having compromised firmware running in the non-secure state, to be reflashed OTA via the hypervisor running in the secure state. (just an example)</p><p>TrustZone also allowed the possibility for specific parts of the system (firmware for radios) to be only run in the secure state and the non-secure state did not have direct access to these resources, so damage caused by a compromised non-secure could be contained.</p><p>Altough it was possible to build secure applications using ARMv7-M as it featured privilaged and non-privilaged states, TrustZone simplified the development process and offered a better implementation for security.</p><p>The Cortex-M23 was to be the next generation replacement for Cortex-M0+.</p><p>It offered almost the same features as the Cortex-M0+, 2 stage in-order integer pipeline, but with added benifits of ARMv8-M Baseline.</p><p>Similarly, the Cortex-M33 was to be the next generation replacement for Cortex-M3 but had features more in-line to Cortex-M4.</p><p>It too offered the same general capabilities as the Cortex-M4 with the added features and security extentions of ARMv8-M Mainline.</p><p>The ARMv8-M did offer compute improvements with a more efficient core design and M23 and M33 were therefore faster than M0+ and M4.</p><p>Another major change in ARMv8-M was the ability for SoC implementor to include Custom instructions via CDE.</p><p>The next big change in the industry came due to rise of another technology, AI and Machine Learning.</p><p>By the late 2010s, AI and ML revolution was on the rise and there was heavy demand in the industry to have the capability to run ML models on the edge.</p><p>ARM responded to this with the introduction of ARMv8.1-M with inclusion of Helium (M-profile Vector Extentions).</p><p>Helium added support for improved and wider vector instructions (than ARMv7E-Ms) that gave the core a major uplift(upto 4x) in throughput for AI/ML applications.</p><p>ARMv8.1-M also bought new architectural features related to security (PACBTI), reliability (RAS), performance monitoring (PMU) and debugging enhancements.</p><p>ARM launched Cortex-M55 in 2020 and Cortex-M85 in 2022 both of which were based on ARMv8.1-M.</p><p>ARM also launched its Ethos NPUs (u55 and u65) which could be integrated with M55 and M85 cores to get even more improved AI/ML throughput.</p><p>Now that you know what each of our condentors are and how they differ from each other lets benchmark them to see how much synthetic difference in performance do they have.</p><h2 id=let-the-battle-begin>Let the battle begin.<a hidden class=anchor aria-hidden=true href=#let-the-battle-begin>#</a></h2><p>Unfortunately, not all of the cores mentioned above are actually available in the market as of today.</p><p>There are large number of products in the market based on the older ARMv6-M and ARMv7-M lineup (Cortex-M0+,M3,M4,M7).</p><p>But only few manufacturers have products that feature the newer ARMv8-M/ARMv8.1-M lineup, the most famous of which currently is the Cortex-M33 followed by M23.</p><p>I could not find any Cortex-M55 based MCU, and Renesas only just released (late september of 2023) the RA8M1 series featuring Cortex-M85.</p><p>I have in hand access to products based on M0+,M3,M4,M7. (I also have a SoC with M33 but that is bare sample chip w/o breakout board)</p><p>Thus we will be benchmarking these M0+,M3,M4 and M7 based products which are still highly popular and currently in use in the industry.</p><p>The performance of each core is highly dependent on the overall system implementation by the SoC vendor and thus these tests are only performed to get a general idea.</p><ul><li><p>The M0+ will be from a RP2040.</p></li><li><p>The M3 will be from a STM32F103C8.</p></li><li><p>The M4 will be from a STM32F410RB.</p></li><li><p>The M7 will be from a MIMXRT1166DVM6A.</p></li></ul><p>First round will focus integer performance.</p><p><img loading=lazy src=/images/arm_bench_int_ipc.png alt="INT IPC"></p><p>Although IPC is a great measure to distinguish core-to-core performance difference, in real world scenarios, the higher performing cores are manufactured on better silicon nodes and have larger pipelines thus natively yeild higher clocks, hence raw throughput on available platforms featuring each core is also provided, although this is an aproximation and the actual value can be higher or lower depending on the test implementation, here 1024 instructions were executed within a loop that was unrolled 32 times, the cycles taken were then used to extrapolate for MIPS (Million Instructions Per Second).</p><p><img loading=lazy src=/images/arm_bench_int_throughput.png alt="INT THROUGHPUT"></p><br><p>The second round will be floating point performance.</p><p>Platforms that feature a FPU will utilize it, others will emulate the operations in software, newlib-nano was used as the glibc (other libraries might perform better but do not come standard with the toolchain).</p><p><img loading=lazy src=/images/arm_bench_fp_ipc.png alt="FP IPC"></p><br><p>The third round will on memory bandwitdh, absolute maximum throughput in read,write will be tested, if the platform offers different types of internal/external memories, all will be tested. The absolute maximum throughput only gives the maximum theoretical achievable bandwith on sythentic workloads, most real world use cases will yeild much lower results.</p><p><img loading=lazy src=/images/arm_bench_mem.png alt="MEM BANDWIDTH"></p><br><p>We can extract the following information from all this data:</p><ul><li>Cortex M7 provides upto 2x IPC in general use cases as compared to other cores as it can dual issue common instructions under certain conditions.</li><li>Cortex M4/M3/M0+ have the same IPC in general add/sub/mul instructions.</li><li>Cortex-M7 due to larger 6 stage pipeline has larger latencies for INT division and all FP instructions, to maximise performance instruction level parallelism must be exploited, GCC does a very bad job at this (even at -O3), so if you have a workload demanding high performance floating point arethmetic be prepared to manually optimise it in assembly.</li><li>Cortex-M7 has very high memory bandwidth with zero latecy for TCM which scales linearly with CPU clock.</li><li>Our Cortex-M7 contender (MIMXRT1166) performs worse on reads than in writes for some memories due to writes being pipelined and issues with NIC priority, OCRAM and SDRAM are optimised for multi-master access.</li><li>FP compute on Cortex-M3 and M0+ is much slower due to no hardware support and software emulation, the real world performance can be greater than what is stated here depending on the implementation of software FPU functions.</li><li>Wierdly, Cortex-M3 featured in this test was based on STM32F103XX platform and yeilds lower results in INT compute per CLK than M0+ due to incursion of multiple branch penelties in throughput test.</li></ul></div><footer class=post-footer><nav class=paginav><a class=next href=http://qcentlabs.com/posts/swd_banger/><span class=title>Next Page »</span><br><span>Making my own Programmer/Debugger using ARM SWD.</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share The Core Wars, ARM Cortex M0+ vs M3 vs M4 vs M7 on twitter" href="https://twitter.com/intent/tweet/?text=The%20Core%20Wars%2c%20ARM%20Cortex%20M0%2b%20vs%20M3%20vs%20M4%20vs%20M7&amp;url=http%3a%2f%2fqcentlabs.com%2fposts%2fcore-wars%2f&amp;hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share The Core Wars, ARM Cortex M0+ vs M3 vs M4 vs M7 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fqcentlabs.com%2fposts%2fcore-wars%2f&amp;title=The%20Core%20Wars%2c%20ARM%20Cortex%20M0%2b%20vs%20M3%20vs%20M4%20vs%20M7&amp;summary=The%20Core%20Wars%2c%20ARM%20Cortex%20M0%2b%20vs%20M3%20vs%20M4%20vs%20M7&amp;source=http%3a%2f%2fqcentlabs.com%2fposts%2fcore-wars%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share The Core Wars, ARM Cortex M0+ vs M3 vs M4 vs M7 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2fqcentlabs.com%2fposts%2fcore-wars%2f&title=The%20Core%20Wars%2c%20ARM%20Cortex%20M0%2b%20vs%20M3%20vs%20M4%20vs%20M7"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share The Core Wars, ARM Cortex M0+ vs M3 vs M4 vs M7 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fqcentlabs.com%2fposts%2fcore-wars%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share The Core Wars, ARM Cortex M0+ vs M3 vs M4 vs M7 on whatsapp" href="https://api.whatsapp.com/send?text=The%20Core%20Wars%2c%20ARM%20Cortex%20M0%2b%20vs%20M3%20vs%20M4%20vs%20M7%20-%20http%3a%2f%2fqcentlabs.com%2fposts%2fcore-wars%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share The Core Wars, ARM Cortex M0+ vs M3 vs M4 vs M7 on telegram" href="https://telegram.me/share/url?text=The%20Core%20Wars%2c%20ARM%20Cortex%20M0%2b%20vs%20M3%20vs%20M4%20vs%20M7&amp;url=http%3a%2f%2fqcentlabs.com%2fposts%2fcore-wars%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://qcentlabs.com/>qcentlabs</a></span>
<span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>